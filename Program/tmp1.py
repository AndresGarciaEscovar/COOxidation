def get_0th_order_equations(self, print_equations=False):
    """ Gets the lowest order exact equations.

        :param print_equations: True, if the equations are to be printed
        once the process finishes. False, otherwise.
    """

    # ----------------------------------------------------------------------
    # Auxiliary functions.
    # ----------------------------------------------------------------------

    def empty_dictionaries():
        """ Resets the dictionaries to empty dictionaries.
        """

        # Set all the entries in the dictionary to empty.
        for key0 in keys:
            decay_dictionary[key0] = []
            create_dictionary[key0] = []

    def get_creation_states(state0, state1):
        """ Appends the states to which the state0 decays for each process.

            :param state0: The list that contains the information of the
            state0, that is the state which is tested for decay.

            [original_state, decay_dictionary, create_dictionary]

            :param state1: The list that contains the information of the
            state which must contain state0.

            [original_state, decay_dictionary]
        """

        # Check all the states belonging to the specific key.
        for key0 in keys:
            # Check all the states generated by the process.
            for statei in state1[1][key0]:
                # Check that the state is a substate of the state, in the lowest order possible.
                if len(statei) == process_orders[key0] and self._get_state1_in_state2(state0[0], statei):
                    # Add the state to the list of generated states.
                    state0[2][key0].append(state1[0])

    def get_decay_states(state0, state1):
        """ Appends the states to which the state0 decays for each process.

            :param state0: The list that contains the information of the
            state0, that is the state which is tested for decay.

            [original_state, decay_dictionary, create_dictionary]

            :param state1: The list that contains the information of the
            state which must contain state0.

            [original_state, decay_dictionary]
        """

        # Only proceed if the state is in the process.
        if not self._get_state1_in_state2(state0[0], state1[0]):
            return

        # Check all the keys.
        for key1 in keys:
            # Append the states to the dictionary if needed.
            if len(state1[0]) == process_orders[key1] and len(state1[1][key1]) > 0:
                state0[1][key1].extend([cp.deepcopy(state1[0]) for _ in state1[1][key1]])

    def get_involved_states():
        """ Gets the states that are involved in the calculation.

            :return involved_states0: A list with the states that are
            involved in the calculation.
        """

        # Auxiliary variables.
        involved_states0 = []

        # The states of the orders that show in the lowest order equations.
        for order0 in self._get_orders():
            involved_states0.extend(self._get_states(order0))

        return involved_states0

    def get_resulting_states():
        """ Gets the resultant states after ALL processes are applied to ALL
            the states.
        """

        # Auxiliary variables.
        resultant_states0 = []

        for state0 in involved_states:
            # Empty the dictionary first.
            decay_dictionary_state0 = {}

            # Get the states to which each state decays due to a process.
            for i, process0 in enumerate(process_functions):
                decay_dictionary_state0[keys[i]] = process0[2](state0)

            # Append the results.
            resultant_states0.append([state0, decay_dictionary_state0])

        return resultant_states0

    def print_states():
        """ Prints a table of the decay states and the creation states of
            all the states in the system.
        """

        # The titles of the columns.
        keyis = "Process"
        decay = "Decay States"
        create = "Create States"

        # Get the information on the strings.
        tmp_key = [len(key) for key in keys]
        tmp_state_create = [len(create)]
        tmp_state_decay = [len(decay)]
        for state0 in self.equations:
            for key in keys:
                tmp_state_decay.append(len(str(state0[1][key])))
                tmp_state_create.append(len(str(state0[2][key])))
        tmp_key.append(len(keyis))

        # Get the maximum lengths.
        max_create = max(tmp_state_create)
        max_decay = max(tmp_state_decay)
        max_key = max(tmp_key)

        # Format strings.
        str1 = "".join(["-" for _ in range(max_key)])
        str2 = "".join(["-" for _ in range(max_decay)])
        str3 = "".join(["-" for _ in range(max_create)])

        # Print the formatted states.
        for state0 in self.equations:
            print(f"Initial state is {state0[0]}:")
            print(f"\t", "|", str1, "|", str2, "|", str3, "|")
            print(f"\t", "|", f"{keyis:^{max_key}}", "|", f"{decay:^{max_decay}}", "|", f"{create:^{max_create}}", "|")
            print(f"\t", "|", str1, "|", str2, "|", str3, "|")
            for key0 in keys:
                print(f"\t", "|", f"{key0:<{max_key}}", "|", f"{str(state0[1][key0]):<{max_decay}}", "|",
                      f"{str(state0[2][key0]):<{max_create}}", "|")
                print(f"\t", "|", str1, "|", str2, "|", str3, "|")
            print("")

    # ----------------------------------------------------------------------
    # Implementation.
    # ----------------------------------------------------------------------

    # First, empty the equations list.
    self.equations = []

    # Get the information of the process functions and process orders.
    process_functions, process_orders = self._get_process_functions()

    # Get the lowest state variables, with the numbering.
    lowest_states = self._get_states(1)

    # Get ALL the states that are potentially involved in the calculation.
    involved_states = get_involved_states()

    # ----------------------------------------------------------------------
    # Get the generated states by each process.
    # ----------------------------------------------------------------------

    # Auxiliary variables.
    decay_dictionary = {}
    create_dictionary = {}

    # Get the keys.
    keys = self._get_keys()

    # Get the resulting states from making the operations.
    resultant_states = get_resulting_states()

    # ----------------------------------------------------------------------
    # Get the resulting states.
    # ----------------------------------------------------------------------

    # Empty the decay and creation dictionaries.
    empty_dictionaries()

    # Check how each state can be generated.
    for low_state in lowest_states:
        # Set the format of the state to the final state.
        low_state = [low_state, cp.deepcopy(decay_dictionary), cp.deepcopy(create_dictionary)]

        # Check every state.
        for resultant_state in resultant_states:
            # Get the decay states.
            get_decay_states(low_state, resultant_state)

            # If the states are different we testing creation.
            get_creation_states(low_state, resultant_state)

        # Add the equation to the list.
        self.equations.append(cp.deepcopy(low_state))

    # Print the table with all the states.
    if print_equations:
        print_states()

def get_nth_order_equations(self, order=0, print_equations=False):
    """ Gets the equations up to the nth order term, i.e., the equations
        of states from 0 to n-1 order. If the order is the same as the
        number of sites, it gives the EXACT equations for the system.

        :param order: The order to which the equations must be obtained. It
        must be an integer in the range [0, self.number_of_sites].

        :param print_equations: True, if the equations are to be printed
        once the process finishes. False, otherwise.
    """

    # ----------------------------------------------------------------------
    # Auxiliary functions.
    # ----------------------------------------------------------------------

    def empty_dictionaries():
        """ Resets the dictionaries to empty dictionaries.
        """

        # Set all the entries in the dictionary to empty.
        for key0 in keys:
            decay_dictionary[key0] = []
            create_dictionary[key0] = []

    def get_creation_states(state0, state1):
        """ Appends the states that create state0 for each process.

            :param state0: The list that contains the information of the
            state0, that is the state which is tested for creation.

            :param state1: The list that contains the information of the
            state which must contain state0.

            [original_state, decay_dictionary]
        """

        # A state cannot be created by itself.
        if self._get_state1_in_state2(state0, state1[0]):
            print("Rejected:")
            print(state0)
            print(state1[0])
            print("")
            return

        print("Accepted:")
        print(state0)
        print(state1[0])
        print("")

        # # Go through all the process the keys.
        # for key0 in keys:
        #     # Go through all the creation states due to a process.
        #     for state0_0 in state1[1][key0]:
        #         # Only append if the original state has decayed.
        #         if self._get_state1_in_state2(state0, state0_0):
        #             create_dictionary[key0].append(cp.deepcopy(state1[0]))
        #             break

    def get_decay_states(state0, state1):
        """ Appends the states to which the state0 decays for each process.

            :param state0: The list that contains the information of the
            state0, that is the state which is tested for decay.

            :param state1: The list that contains the information of the
            state which must contain state0.

            [original_state, decay_dictionary]
        """

        # Only proceed if the state is in the process.
        if not self._get_state1_in_state2(state0, state1[0]):
            return

        # Go through all the process the keys.
        for key0 in keys:
            # Go through all the decay states due to a process.
            for state0_0 in state1[1][key0]:
                # Only append if the original state has decayed.
                if not self._get_state1_in_state2(state0, state0_0):
                    decay_dictionary[key0].append(cp.deepcopy(state1[0]))

    def get_filtered_contracted_states(state0, states0):
        """ Gets a list of all the UNIQUE states, with the number of times
            it appears in the list.

            :param state0: The target state to be obtained by contraction.

            :param states0: The list of states to be filtered.

            :return filtered_states0: The list of filtered states.
        """

        print(state0)

        # Proceed only if the list length is greater than zero.
        if len(states0) == 0:
            return states0

        # Get a list of all the UNIQUE states and get the count of them.
        filtered_states0 = cp.deepcopy(states0)
        filtered_states0 = sorted(list(set(filtered_states0)), key=lambda x: (len(x), x[0][0], x[0][1]))

        # Number of unique states.
        unique_state_length0 = -1

        # Contract the states if needed.
        while not unique_state_length0 == len(filtered_states0):
            # Get the list of all the combinations needed to contract a state.
            nplets_combinations0 = tuple(itertools.combinations(filtered_states0, len(self.states)))

            # If there are no triplet combinations.
            if len(nplets_combinations0) == 0:
                break

            # Try contract the nplets at both sides.
            for nplets_combination0 in nplets_combinations0:
                contracted0_0 = self._get_contracted_state(nplets_combination0, -1)
                contracted0_1 = self._get_contracted_state(nplets_combination0, 0)

                # If there are contracted indexes towards the right.
                if len(contracted0_0[0]) > 1 and self._get_state1_in_state2(state0, contracted0_0[0]):
                    filtered_states0 = [state0_2 for state0_2 in filtered_states0 if state0_2 not in contracted0_0[1]]

                    # Add the state as needed.
                    if contracted0_0[0] not in filtered_states0:
                        filtered_states0.append(contracted0_0[0])

                    break

                # If there are contracted indexes towards the left.
                if len(contracted0_1[0]) > 1 and self._get_state1_in_state2(state0, contracted0_1[0]):
                    filtered_states0 = [state0_2 for state0_2 in filtered_states0 if state0_2 not in contracted0_1[1]]

                    # Add the state as needed.
                    if contracted0_1[0] not in filtered_states0:
                        filtered_states0.append(contracted0_1[0])

                    break

        # ------------------------------------------------------------------
        # Get the multiplicity of the terms.
        # ------------------------------------------------------------------

        # Auxiliary variables.
        tmp_filtered = cp.deepcopy(filtered_states0)

        # Empty the filtered states.
        filtered_states0 = []

        # Get the new filtered states.
        for state0 in tmp_filtered:
            # Get each state's multiplicity.
            num = 1 if states0.count(state0) == 0 else states0.count(state0)

            # Add to the list.
            filtered_states0.append(tuple([state0, num]))

        return filtered_states0

    def get_involved_states():
        """ Gets the states that are involved in the calculation.

            :return involved_states0: A list with the states that are
            involved in the calculation.
        """

        # Auxiliary variables.
        involved_orders0 = [order]
        involved_states0 = []
        orders0 = []

        # ------------------------------------------------------------------
        # Get the orders involved.
        # ------------------------------------------------------------------

        # Get the orders of the processes.
        orders0.extend(self._get_orders())

        # Get the order of the states for which the gains/decays will happen.
        length_states0 = set(tuple(map(len, lowest_states)))

        # Get the orders of the states involved in the calculations.
        for order0 in orders0:
            # State of the current order will always be involved.
            involved_orders0.append(order0)

            # Get the specific order of each state.
            for length_state0 in length_states0:
                # Use the criteria to add the states.
                involved_orders0.extend([k for k in range(order0, order0 + length_state0)])

        # Filter the involved orders.
        involved_orders0 = set(involved_orders0)
        involved_orders0 = [k for k in involved_orders0 if order <= k <= self.number_of_sites]

        # Get ALL the involved states.
        for order0 in involved_orders0:
            involved_states0.extend(self._get_states(order0))

        return involved_states0

    def get_lowest_states():
        """ Gets the states that are involved in the calculation.

            :return involved_states0: A list with the states that are involved in the
            calculation.
        """

        # Auxiliary variables.
        involved_states0 = []

        # ----------------------------------------------------------------------------------------------------------
        # Get the states that are involved in the calculation.
        # ----------------------------------------------------------------------------------------------------------

        # If the order is greater than the number of sites.
        if order >= self.number_of_sites:
            # Only get the states at the highest order possible.
            for involved_state0 in self._get_states(self.number_of_sites):
                involved_states0.append(involved_state0)

            return involved_states0

        # Get ALL the states up to the lowest order possible.
        for k in range(2, order + 1):
            for involved_state0 in self._get_states(k):
                involved_states0.append(involved_state0)

        return involved_states0

    def get_resulting_states():
        """ Gets the resultant states after ALL processes are applied to ALL
            the states.
        """

        # Auxiliary variables.
        resultant_states0 = []

        for state0 in involved_states:
            # Empty the dictionary first.
            decay_dictionary_state0 = {}

            # Get the states to which each state decays due to a process.
            for k, process0 in enumerate(process_functions):
                decay_dictionary_state0[keys[k]] = process0[2](state0)

            # Append the results.
            resultant_states0.append([state0, decay_dictionary_state0])

        return resultant_states0

    def validate_order():
        """ Makes sure that the chosen order is valid, i.e., a positive
            integer greater than zero.
        """

        # The order must be a positive integer greater than zero.
        if not isinstance(order, (int,)) or order <= 0:
            raise ValueError(
                f"The order parameter must be an integer number greater than zero. Current value: {order}.")

    # # ----------------------------------------------------------------------
    # # Implementation.
    # # ----------------------------------------------------------------------
    #
    # # Get the zeroth order equations, these will serve as the basis.
    # if order == 0 or order < self.number_of_sites:
    #     self.get_0th_order_equations(print_equations)
    #
    #     # Get the equations to the lowest order.
    #     if order == 0 or order == 1:
    #         return

    # ----------------------------------------------------------------------
    # Get the equations for the nth order term; do not empty the
    # exact equations, these will serve as the basis.
    # ----------------------------------------------------------------------

    # Validate that the order is correct.
    validate_order()

    # Get the information of the process functions and process orders.
    process_functions, process_orders = self._get_process_functions()

    # Get states for which the equations will be obtained.
    lowest_states = get_lowest_states()

    # Get ALL the states that are potentially involved in the calculation.
    involved_states = get_involved_states()
    #
    # # ----------------------------------------------------------------------
    # # Get the generated states by each process.
    # # ----------------------------------------------------------------------

    # Auxiliary variables.
    decay_dictionary = {}
    create_dictionary = {}

    # Get the keys.
    keys = self._get_keys()

    # Get the resulting states from making the operations.
    resulting_states = get_resulting_states()

    # Go through each lowest order state.
    for i, state_0 in enumerate(lowest_states):

        # Empty the dictionaries.
        empty_dictionaries()

        # Get the decay states.
        # for j, state_1 in enumerate(resulting_states):
        # Get the decay states for the lowest order state.
        # get_decay_states(state_0, state_1)

        # Get the create states for the lowest order state.
        # get_creation_states(state_0, state_1)
        # pass

        for key in keys:
            # decay_dictionary[key] = get_filtered_contracted_states(state_0, decay_dictionary[key])
            # create_dictionary[key] = get_filtered_contracted_states(state_0, cp.deepcopy(create_dictionary[key]))
            pass

def _generate_equation(self, equation, gather_by_state, format_string="latex", order=0):
    """ Generates a single equation in the required format; ideal to
        generate LaTeX style equations for a Jupyter notebook.

        :param equation: A list that represents an equation. Must be in the
        format

        [state, decay_dictionary, creation_dictionary]

        :param gather_by_state: True, if the terms must be factorized by
        state. False, if the terms must be factorized by reaction constant.

        :param format_string: The type of formatting that must be applied to
        the strings.

        :param order: The order to which approximate the terms. Must
        be an integer greater than or equal to zero.

        :return: A string that represents the equations in LaTeX format.
    """

    # ----------------------------------------------------------------------
    # Auxiliary functions.
    # ----------------------------------------------------------------------

    def get_gathered_by_constant():
        """ Returns the LaTeX equation string gathered by rate constant.

            :return: The LaTeX equation string gathered by rate constant.
        """

        # ------------------------------------------------------------------
        # Implementation.
        # ------------------------------------------------------------------

        # Auxiliary variables.
        equation_string0 = ""

        # Go through each rate constant.
        for key0 in keys:
            # Get the representation of the key.
            key_string0 = get_string(key0, rate_constant=True)

            # --------------------------------------------------------------
            # Decay terms.
            # --------------------------------------------------------------

            # Get all the decay terms.
            decay_terms0 = []
            if len(equation[1][key0]) > 0:
                decay_terms0.extend(list(map(get_string, equation[1][key0])))

            # --------------------------------------------------------------
            # Creation terms.
            # --------------------------------------------------------------

            # Get all the creation terms.
            creation_terms0 = []
            if len(equation[2][key0]) > 0:
                creation_terms0.extend(list(map(get_string, equation[2][key0])))

            # --------------------------------------------------------------
            # Join the two strings; three cases to contemplate.
            # --------------------------------------------------------------

            # There are decay terms, but no creation terms.
            if len(decay_terms0) > 0 and len(creation_terms0) == 0:
                # Join all the terms.
                decay_string0 = f"-{key_string0} (" + "+".join(decay_terms0) + ")"

                # Remove parentheses if needed.
                if len(decay_terms0) == 1:
                    decay_string0 = "".join(decay_string0.split("("))
                    decay_string0 = "".join(decay_string0.split(")"))

                # Be sure to delete leading and trailing spaces.
                decay_string0 = decay_string0.strip()

                # Join the terms to the string.
                equation_string0 += decay_string0

            # There are no decay terms, but there are creation terms.
            elif len(decay_terms0) == 0 and len(creation_terms0) > 0:
                # Join all the terms.
                create_string0 = f"{key_string0} (" + "+".join(creation_terms0) + ")"

                # Remove parentheses if needed.
                if len(creation_terms0) == 1:
                    create_string0 = "".join(create_string0.split("(")).strip()
                    create_string0 = "".join(create_string0.split(")")).strip()

                # Be sure to delete leading and trailing spaces.
                create_string0 = create_string0.strip()

                # Join the terms to the string.
                equation_string0 += "+" + create_string0

            # There are both decay terms and creation terms.
            elif len(decay_terms0) > 0 and len(creation_terms0) > 0:
                # Set the digit string to empty.
                decay_string0 = "-".join(decay_terms0)
                create_string0 = "+".join(creation_terms0)

                # Join the terms to the string.
                equation_string0 += f"+{key_string0} (" + create_string0 + "-" + decay_string0 + ")"

        # ------------------------------------------------------------------
        # Finish formatting the equation.
        # ------------------------------------------------------------------

        # Fix the equation.
        equation_string0 = equation_string0[1:] if equation_string0[0] == "+" else equation_string0
        equation_string0 = " + ".join(equation_string0.split("+")).strip()
        equation_string0 = " - ".join(equation_string0.split("-")).strip()
        equation_string0 = "-" + equation_string0[2:] if equation_string0[0] == "-" else equation_string0

        return equation_string0

    def get_gathered_by_state():
        """ Returns the LaTeX equation string gathered by state.

            :return: The LaTeX equation string gathered by state.
        """

        # ------------------------------------------------------------------
        # Auxiliary functions.
        # ------------------------------------------------------------------

        def get_all_states():
            """ Returns a list of all the unique states that appear in the
                equation.

                :return states1: A list of all the unique states that appear
                in the equation.
            """

            # Auxiliary variables.
            states1 = []

            # Get all the states for all the processes.
            for key1 in keys:
                # Get the states that make the current state decay.
                for state1 in equation[1][key1]:
                    states1.append(state1)

                # Get the states create the current state.
                for state1 in equation[2][key1]:
                    states1.append(state1)

            # Get a list of unique states.
            states1 = list(set(tuple(states1)))

            return states1

        def get_key_count(state1, key1):
            """ Returns the number of overall number of times the state
                appears for a certain rate constant.

                :param state1: The state that is being looked for.

                :param key1: The key of the entry in the dictionary.

                :return: The number of overall number of times the state
                appears for a certain rate constant.
            """

            # Count the number of times the constant appears in the
            # each of the keys.
            key_count1 = 0

            # Subtract one if the state decays.
            if state1 in equation[1][key1]:
                key_count1 -= 1

            # Subtract one if the state is created.
            if state1 in equation[2][key1]:
                key_count1 += 1

            return key_count1

        # ------------------------------------------------------------------
        # Implementations.
        # ------------------------------------------------------------------

        # Auxiliary variables.
        equation_string0 = ""

        # Get all the unique states..
        states0 = get_all_states()

        # Look for the state in the original dictionaries.
        for state0 in states0:
            # Save the keys that are present.
            keys_present0 = []

            # Look for the state in all the keys.
            for key0 in keys:
                # Get the formatted key.
                key_string0 = get_string(key0, rate_constant=True)

                # Get the number of times the state appears in the terms.
                key_count0 = get_key_count(state0, key0)

                # If the state does not exists in either of the given key,
                # go the next one.
                if key_count0 == 0:
                    continue

                # Format the key properly.
                key_string0 = str(abs(key_count0)) + key_string0 if abs(key_count0) > 1 else key_string0
                key_string0 = "-" + key_string0 if key_count0 < 0 else key_string0

                # Add the key to the list of keys
                keys_present0.append(key_string0)

            # --------------------------------------------------------------
            # Join to the equation string.
            # --------------------------------------------------------------

            if len(keys_present0) == 1:
                # Format the string properly.
                key_string0_1 = "".join(keys_present0) + " " + get_string(state0)

                # Add to the equation string.
                equation_string0 += key_string0_1 if key_string0_1[0] == "-" else "+" + key_string0_1
            else:
                # Format the string properly.
                key_string0_1 = "".join([string0 if string0[0] == "-" else "+" + string0 for string0 in keys_present0]).strip()
                key_string0_1 = key_string0_1[1:] if key_string0_1[0] == "+" else key_string0_1
                key_string0_1 = "(" + key_string0_1 + ") " + get_string(state0)

                # Add to the equation string.
                equation_string0 += "+" + key_string0_1

        # Format the equation further.
        equation_string0 = equation_string0.strip()
        equation_string0 = equation_string0[1:] if equation_string0[0] == "+" else equation_string0
        equation_string0 = " + ".join(equation_string0.split("+")).strip()
        equation_string0 = " - ".join(equation_string0.split("-")).strip()
        equation_string0 = "-" + equation_string0[2:] if equation_string0[0] == "-" else equation_string0

        return equation_string0

    def get_string(state0, rate_constant=False):
        """ Gets the string representation of the given state, or rate
            constant.

            :param state0: The state for which the string representation is
             required.

            :param rate_constant: If it is a rate constant the one that is
            required.
            :return: The string representation of the given state in the
            requested format.
        """

        return formatter(state0, order=order, rate_constant=rate_constant)

    # ----------------------------------------------------------------------
    # Implementation.
    # ----------------------------------------------------------------------

    # Define the format in which the equation must be obtained.
    formatter = EquationFormatter.get_formatter(format_string)

    # Get the keys of the processes.
    keys = self._get_keys()

    # Get the differential of the state.
    equation_string = formatter(equation[0], derivative=True, order=order) + " ="
    equation_string += "= " if format_string == "mathematica" else " "

    # Write the results gathered in the requested order.
    equation_string += get_gathered_by_state().strip() if gather_by_state else get_gathered_by_constant().strip()

    return equation_string

