""" Equation formatter for LaTeX.
"""

# Imports
import copy as cp

# Imports: User
from .equation_formatter import EquationFormatter


class LaTeXFormatter(EquationFormatter):
    """ A static class that contains equation formatting functions that are
        generated by the equation generator.
    """

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Public Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # CONSTANTS.
    # --------------------------------------------------------------------------

    @staticmethod
    def get_equation(equation, order=0):
        """ Gets the string that represents a state in LaTeX format.

            :param equation: The variable that contains the state and its
            constituents for which to get the equation.

            :param order: The order to which the state must be expanded. Order
            zero means the state must not be modified. Higher orders means the
            state must be mean-field expanded to the given order.

            :return equation_string: The string that represents the state in
            LaTeX format.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        def validate_equation():
            """ Validates that the equation is given in the proper format.
                    (state, create states dictonary, decay states dictionary)
            """

            # Check that the equation is tuple.
            if not isinstance(equation, (tuple,)):
                raise TypeError(f"The equation must be a tuple. Current type: {type(equation)}.")

            # Of length 3.
            elif not len(equation) == 3:
                raise TypeError(f"The equation must be a tuple of three entries."
                                f" Current type: {type(equation)}, Length = {len(equation)}"
                                )

            # Validate that the zeroth entry is a state.
            validate_state(equation[0])

            # Validate that the first and second entries are dictionaries.
            if not (isinstance(equation[1], (dict,)) and isinstance(equation[2], (dict,))):
                raise TypeError("The two last entries of the tuple must be dictionaries. "
                                f" Dictionary entry [1] = {type(equation[1])},"
                                f" Dictionary entry [2] = {type(equation[2])}."
                                )

            # Get the keys to the dictionaries.
            keys0_1 = set(key0 for key0 in equation[1].keys())
            keys0_2 = set(key0 for key0 in equation[2].keys())

            # If their keys are different.
            if not keys0_1 == keys0_2:
                raise ValueError(f"Both Dictionaries must have the same keys"
                                 f" Keys for equation[1]: {keys0_1},"
                                 f" Keys for equation[2]: {keys0_2}.")

        def validate_state(state0):
            """ Validates that the state is given in the proper format.

                :param state0: A state that must be in the format,
                    ((particle0, index0), ... ,(particleN, indexN),).
            """

            # Check that it is a tuple.
            if not isinstance(state0, (tuple,)):
                raise TypeError(f"The state parameter must be a tuple. Current type: {type(state0)}")

            # Check that the elements are tuples.
            for j0, substate0 in enumerate(state0):
                # Check that it is a tuple.
                if not isinstance(substate0, (tuple,)):
                    raise TypeError(f"The substates of a state must be tuple."
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0}, Current type: {type(substate0)}"
                                    )

                # Of length 2.
                elif not len(substate0) == 2:
                    raise TypeError(f"The substates of a state must be tuple of length 2. "
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0},  Current length of substate: {len(substate0)}."
                                    )

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Validate the equation.
        validate_equation()

        # Auxiliary variables.
        keys = tuple(key for key in equation[1].keys())

        # Get the differential form.
        diff_state = "\\frac{" + LaTeXFormatter.get_state(equation[0]) + "}{dt} = "

        # For every key.
        for key in keys:
            string_key = LaTeXFormatter.get_rate(key)

    @staticmethod
    def get_rate(rate):
        """ Gets the string that represents a rate constant in LaTeX format.

            :param rate: The rate to check. If in the format,
                 "'s1'.'s2'. ... .'sN'.."
            it interprets the periods as sub-indexes of level N.

            :return rate_string: The rate constant in the given representation.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        def validate_rate():
            """ Validates that the rate is given in the proper format.

                :param rate: The rate to check. If in the format,
                     "'s1'.'s2'. ... .'sN'.."
                it interprets the periods as sub-indexes of level N.
            """

            # Check that it is a string.
            if not isinstance(rate, (str,)):
                raise TypeError(f"The rate parameter must be string. Current type: {type(rate)}")

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Validate the form of the rate.
        validate_rate()

        # Split the string.
        rate_string = rate.split(".")

        # Join the string properly.
        rate_string = "_{".join(rate_string) + "}" * (len(rate_string) - 1)

        return rate_string

    @staticmethod
    def get_state(state, order=0):
        """ Gets the string that represents a state in LaTeX format.

            :param state: A state in the format,
                ((particle0, index0), ... ,(particleN, indexN),).

            :param order: The order to which the state must be approximated.
            If zero, the state is NOT approximated.

            :return state_string: The state, to the given order, in LaTeX
            format.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        def format_entry(entry0):
            """ Formats an entry of a state properly.

                :param entry0: The entry to be formatted.

                :return entry_string0: The entry of a state in string format.
            """

            entry_string0 = f"{entry0[0]}" + "_{" + f"{entry0[1]}"  + "}"

            return entry_string0

        def get_denominator():
            """ Gets the denominator for the equations. This is obtained from
                the numerator.

                :return: The list of states that is generated from the
                numerator, that will go in the denominator.
            """

            # Auxiliary variables.
            state_list0 = []

            # For every ith state.
            for i, state0_0 in enumerate(numerator_states):
                # For every jth state.
                for j, state0_1 in enumerate(numerator_states):
                    # The denominator will be the intersection of the states.
                    if j <= i:
                        continue

                    # Get the intersecting states.
                    intersecting_states0 = list(set(state0_0).intersection(set(state0_1)))

                    # If there are intersecting states.
                    if len(intersecting_states0) > 0:
                        # Extend the list if there is intersection.
                        state_list0.append(intersecting_states0)

            return state_list0

        def get_numerator():
            """ Gets the split state to the nth order, using a mean-field
                approximation.

                :return: A list of the states that is generated from an nth
                order mean field approximation.
            """

            # Auxiliary variables.
            state_list0 = []

            # For every index in the state.
            for i, _ in enumerate(state):
                # Cannot generate more states.
                if i + order > len(state):
                    break

                # Append the substate.
                state_list0.append(state[i: i + order])

            return state_list0

        def get_state_string(state0):
            """ Given a state it returns the string representation.

                :param state0: A tuple of two-tuples.

                :return state_string0_0: The CLOSED reprensentation of a state.
            """

            # Get the list of entries.
            entries0 = list(map(format_entry, state0))

            # Get the exact representation of the state.
            state_string0_0 = "\\left<" + ",".join(entries0) + "\\right>"

            return state_string0_0

        def validate_state():
            """ Validates that the state is given in the proper format.

                :param state: A state that must be in the format,
                    ((particle0, index0), ... ,(particleN, indexN),).
            """

            # The order must a number greater than zero.
            if not 0 <= order:
                raise ValueError(f"The order must be a positive value. Current Value {order}.")

            # Check that it is a tuple.
            if not isinstance(state, (tuple,)):
                raise TypeError(f"The state parameter must be a tuple. Current type: {type(state)}")

            # Check that the elements are tuples.
            for j, substate in enumerate(state):
                # Check that it is a tuple.
                if not isinstance(substate, (tuple,)):
                    raise TypeError(f"The substates of a state must be tuple."
                                    f" State = {state}, Substate Entry = {j},"
                                    f" Substate = {substate}, Current type: {type(substate)}"
                                    )

                # Of length 2.
                elif not len(substate) == 2:
                    raise TypeError(f"The substates of a state must be tuple of length 2. "
                                    f" State = {state}, Substate Entry = {j},"
                                    f" Substate = {substate},  Current length of substate: {len(substate)}."
                                    )

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Always validate the state.
        validate_state()

        # If the requested order is zero.
        if order == 0 or order >= len(state):
            # Get the string representation of the state.
            state_string = get_state_string(state)

            return state_string

        # Split the state in the requested order.
        numerator_states = get_numerator()

        # Get the denominator states.
        denominator_states = get_denominator()

        # ----------------------------------------------------------------------
        # Get the strings for the numerator and denominator.
        # ----------------------------------------------------------------------

        # Strings for the numerator states.
        numerator_states = list(map(get_state_string, numerator_states))

        # Format the string.
        state_string = "".join(numerator_states)

        # Get the denominator strings.
        if len(denominator_states) > 0:
            # Strings for the denominator states.
            denominator_states = list(map(get_state_string, denominator_states))

            # Format the string.
            state_string = "\\frac{" + state_string + "}{" + "".join(denominator_states) + "}"

        return state_string

