import copy as cp


class MathematicaGenerator:

    # --------------------------------------------------------------------------
    # Get methods.
    # --------------------------------------------------------------------------

    def get_states_order(self, order=1):
        """ Given the order, it returns ALL the possible combinations of the
            system variables, i.e., all the possible combinations of the
            variables in n slots.

            :param order: The order of the requested possible variables.

            :return all_states: All the variables of the given order.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        def get_level(state0, counter0):
            """ Recursively generates all the possible states and saves them in
                an external array.
                :param state0:
                :param counter0:
                :return:
            """
            # Stop the recursion.
            if counter0 == order:
                all_states.append(cp.deepcopy(state0))
                return

            # Recursive step to generate the state.
            for state in self.states:
                state_tmp = cp.deepcopy(state0)
                state_tmp.append(state)
                get_level(state_tmp, counter0 + 1)

        def validate_order():
            """ Validates that the order to which the equatios are requested
                are valid.
            """

            # Check the requested order is greater than zero.
            if order <= 0:
                raise ValueError("The order parameter must be greater than zero.")

            # Check that the order parameter is not more than the number of sites.
            if order > self.sites:
                raise ValueError(f"The order parameter must less than or equal to {self.sites}.")

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Auxiliary variable.
        all_states = []

        # Validate that the order is valid.
        validate_order()

        # Get the levels.
        get_level([], 0)

        return all_states

    def get_possible_numbering(self, state):
        """ Given a state, it returns the possible states that the system can
            have.

            :param state: The state to be numbered.

            :return: The list of possible numbered states.
        """

        # Auxiliary variables.
        all_states = []

        # Explore all the possibilities.
        for i in range(self.sites):
            # Only attempt if there are enough sites.
            if i + len(state) > self.sites:
                break

            # Make a deep copy of the state.
            tmp_state = cp.deepcopy(state)

            # Get the
            tmp_list = list(range(i, i+len(state)))

            all_states.append([(tmp_state[j], x + 1) for j, x in enumerate(tmp_list)])

        return all_states

    def get_site_in_state(self, site, state):
        """ Given a site and a state, it determines if the state is related to
            the site, i.e., the state has a numbering such that the number of
            the site appears.

            :param site: The site that is being searched.

            :param state: The state that is properly labeled.

            :return: True, if the site in the equation. False, otherwise.
        """

        # ----------------------------------------------------------------------
        # Auxiliary states.
        # ----------------------------------------------------------------------

        def validate_state():
            """ Validates if the state is valid, i.e., has the appropriate
                length.
            """

            if len(state) > self.sites:
                raise ValueError(f"The size of the state must be, at most, {self.sites}"
                                 f"Current size: {len(state)}")

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Validate the state.
        validate_state()

        # Get the numbering of the states.
        sites = [x[1] for x in state]

        return site in sites

    # --------------------------------------------------------------------------
    # Carbon monoxide exclusive methods.
    # --------------------------------------------------------------------------

    def carbon_monoxide_adsorb(self, site, initial_state):
        """
            Given a state, returns the list of states that are generated by the
            adsorption of carbon monoxide.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of carbon monoxide adsorption.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check ALL sites
        for i in range(0, 3):
            # Always make a copy of the list.
            tmp = cp.deepcopy(initial_state)

            # Check which sites can adsorb carbon monoxide and do the process.
            if tmp[i] == "E":
                tmp[i] = "CO"
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    def carbon_monoxide_desorb(self, site, initial_state):
        """
            Given a state, returns the list of states that are generated by the
            desorption of carbon monoxide.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of carbon monoxide desorption.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check both sites
        for i in range(0, 3):
            # Always make a copy of the list.
            tmp = cp.deepcopy(initial_state)

            # Check which sites can desorb carbon monoxide and do the process.
            if tmp[i] == "CO":
                tmp[i] = "E"
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    def carbon_monoxide_diffusion(self, site, initial_state):
        """
            Given a state, returns the list of states that are generated by the
            diffusion of carbon monoxide to adjacent sites.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of carbon monoxide diffusion to adjacent sites.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check both sites
        for i in range(0, 2):
            # Auxiliary variables.
            j = i + 1

            # Always make a copy of the initial state.
            tmp = cp.deepcopy(initial_state)

            # Try to make the diffusion happen.
            if (tmp[i] == "CO" and tmp[j] == "E") or (tmp[i] == "E" and tmp[j] == "CO"):
                # Exchange the particles.
                tmp[i], tmp[j] = tmp[j], tmp[i]

                # Append to the list.
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    # --------------------------------------------------------------------------
    # Oxygen exclusive methods.
    # --------------------------------------------------------------------------

    def oxygen_adsorb(self, site, initial_state):
        """ Given a state, returns the list of states that are generated by the
            adsorption of oxygen.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of oxygen adsorption.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check both sites
        for i in range(0, 2):
            # Auxiliary variables.
            j = i + 1

            # Always make a copy of the list.
            tmp = cp.deepcopy(initial_state)

            # Check which sites can adsorb oxygen and do the process.
            if tmp[i] == "E" and tmp[j] == "E":
                tmp[i], tmp[j] = "O", "O"
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    def oxygen_desorb(self, site, initial_state):
        """ Given a state, returns the list of states that are generated by the
            desorption of oxygen.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of oxygen desorption.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check both sites
        for i in range(0, 2):
            # Auxiliary variables.
            j = i + 1
            # Always make a copy of the list.
            tmp = cp.deepcopy(initial_state)

            # Check which sites can desorb oxygen and do the process.
            if tmp[i] == "O" and tmp[j] == "O":
                tmp[i], tmp[j] = "E", "E"
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    def oxygen_diffusion(self, site, initial_state):
        """ Given a state, returns the list of states that are generated by the
            diffusion of oxygen to adjacent sites.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the process of oxygen diffusion to adjacent sites.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # Define the list of possible final states.
        final_states = []

        # Check both sites
        for i in range(0, 2):
            # Auxiliary variables.
            j = i + 1
            # Always make a copy of the initial state.
            tmp = cp.deepcopy(initial_state)

            # Try to make the diffusion happen.
            if (tmp[i] == "O" and tmp[j] == "E") or (tmp[i] == "E" and tmp[j] == "O"):
                # Exchange the particles.
                tmp[i], tmp[j] = tmp[j], tmp[i]

                # Append to the list.
                final_states.extend([tmp])

        # Get the unique elements.
        final_states = MathematicaGenerator.get_unique(final_states)

        # Determine if the final states are valid.
        for state in final_states:
            MathematicaGenerator.validate_state(state)

        return final_states

    # --------------------------------------------------------------------------
    # Reaction Carbon monoxide - oxygen, exclusive methods.
    # --------------------------------------------------------------------------

    def lh_reaction(self, site, initial_state):
        """
            Given a state, returns the list of states that are generated by the
            Langmuir-Hinshelwood reaction of carbon monoxide and oxygen; i.e.,
            oxygen and carbon monoxide on adjacent sites react and immediately
            desorb.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to the Langmuir-Hinshelwood reaction of carbon monoxide and oxygen.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        def get_state_and_numbering(state0):
            """ Given a list of 2-tuples that represent a state, returns the
                un-indexed list that represents a state and the numbering of
                the state.

                :param state0: A list of 2-tuples that represent the state and
                the numbering.

                :return: An organized tuple with the state and a tuple with the
                numbering of the state.
            """

            # Auxiliary variables.
            state_list = []
            numbering_list = []

            # Get the list of elements and the numbering.
            for elem0 in state0:
                state_list.append(cp.deepcopy(elem0[0]))
                numbering_list.append(cp.deepcopy(elem0[1]))

            return tuple(state_list), tuple(numbering_list)

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Get the state and the numbering.
        state, numbering = get_state_and_numbering(initial_state)

        # Determine if the state is valid for analysis.
        self.validate_state(state, numbering)

        # Only states that have more than one slot, and the site is not in the
        # numbering list, can react.
        if len(state) < 2 or site not in numbering:
            return initial_state, []

        # Define the list of possible final states.
        final_states = []

        # Check ALL site pairs.
        for i in range(0, 2):
            # Auxiliary variables.
            j = i + 1
            # Always make a copy of the list.
            tmp = cp.deepcopy(initial_state)

            # Try to make the reaction happen.
            if (tmp[i] == "CO" and tmp[j] == "O") or (tmp[i] == "O" and tmp[j] == "CO"):
                tmp[i], tmp[j] = "E", "E"
                final_states.extend([tmp])
        #
        # # Get the unique elements.
        # final_states = MathematicaGenerator.get_unique(final_states)
        #
        # # Determine if the final states are valid.
        # for state in final_states:
        #     MathematicaGenerator.validate_state(state)
        #
        # return final_states

    def er_reaction(self, site, initial_state):
        """
            Given a state, returns the list of states that are generated by the
            gas-phase reaction oxygen on the surface with gaseous carbon
            monoxide in the environment; i.e., a surface oxygen and gaseous
            carbon monoxide Elay-Rideal reaction.

            :param initial_state: The state to be analyzed.

            :return: final_states: A list of final states that are generated due
            to a surface oxygen and gaseous carbon monoxide Elay-Rideal
            reaction.
        """

        # Determine if the state is valid for analysis.
        MathematicaGenerator.validate_state(initial_state)

        # # Define the list of possible final states.
        # final_states = []

        # # Check ALL sites
        # for i in range(0, 3):
        #     # Always make a copy of the list.
        #     tmp = cp.deepcopy(initial_state)
        #
        #     # Check which sites can have an Elay-Rideal reaction.
        #     if tmp[i] == "O":
        #         tmp[i] = "E"
        #         final_states.extend([tmp])
        #
        # # Get the unique elements.
        # final_states = MathematicaGenerator.get_unique(final_states)
        #
        # # Determine if the final states are valid.
        # for state in final_states:
        #     MathematicaGenerator.validate_state(state)

        # return final_states

    # --------------------------------------------------------------------------
    # Validation methods.
    # --------------------------------------------------------------------------

    def validate_state(self, state, numbering):
        """ Validates that the state is a list of three items and those items
            are in the list ["CO", "O", "E"].
        """

        # ----------------------------------------------------------------------
        # Check the state.
        # ----------------------------------------------------------------------

        if not isinstance(state, (tuple,)):
            raise ValueError(f"The type of the state is not valid. Current  type: {type(state)}.")

        if not 1 <= len(state) <= self.sites:
            raise ValueError(f"The current length of the state list is not valid, it must be"
                             f"in the range [1, {self.sites}].  Current legth: {len(state)}.")

        if not all(map(lambda x: x in self.states, state)):
            raise ValueError(f"The states are not valid, they must be in the list {self.states}."
                             f" Current state: {state}.")

        # ----------------------------------------------------------------------
        # Check the numbering.
        # ----------------------------------------------------------------------

        if not isinstance(numbering, (tuple,)):
            raise ValueError(f"The type of the numbering is not valid. Current  type: {type(numbering)}.")

        if not 1 <= len(numbering) <= self.sites:
            raise ValueError(f"The current length of the numbering list is not valid, it must be"
                             f"in the range [1, {self.sites}].  Current legth: {len(numbering)}.")

        if not all(map(lambda x: 0 < x <= self.sites, numbering)):
            raise ValueError(f"The numbering of the states must be in the range [1, {self.sites}]."
                             f" There is an index that is not in this range: {numbering}")

        if not len(set(numbering)) == len(numbering):
            raise ValueError(f"Indexes in the numbering list MUST be unique."
                             f" There is a non-unique index: {numbering}")

    # --------------------------------------------------------------------------
    # Validation methods.
    # --------------------------------------------------------------------------

    def __init__(self):
        """ Creates a MathematicaGenerator object and initializes its
            properties.
        """

        # Define the number of sites.
        self.sites = 3

        # Define the possible states each site of the system can take.
        self.states = ["CO", "O", "E"]


if __name__ == "__main__":

    tmp = MathematicaGenerator()

    tmp_array = []
    for i in range(tmp.sites):
        states = tmp.get_states_order(i + 1)
        for state in states:
            tmp_array.extend(tmp.get_possible_numbering(state))

    all_site_2 = [x for x in tmp_array if tmp.get_site_in_state(2, x)]

    for site in tmp_array:
        tmp.lh_reaction(1, site)

