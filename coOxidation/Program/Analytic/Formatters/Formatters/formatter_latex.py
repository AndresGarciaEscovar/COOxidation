""" Equation formatter for LaTeX."""

# ------------------------------------------------------------------------------
# Imports.
# ------------------------------------------------------------------------------

# Imports: General.
from typing import Union

# Imports: User-defined.
from coOxidation.Program.Analytic.Interfaces.formatter import Formatter

# ------------------------------------------------------------------------------
# Classes.
# ------------------------------------------------------------------------------


class LaTeXFormatter(Formatter):
    """ A static class that contains equation formatting functions that are
        generated by the equation generator.
    """

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Methods.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Format Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def format_constraint(constraint: tuple) -> str:
        """ Gets the string that represents a constraint of the system in
            LaTeX format.

            :param constraint: The variable that contains a constraint, in the
             form of an equality.

            :return: The string that represents the constraint in LaTeX format.
        """

        # Format the left side.
        left_side = LaTeXFormatter.format_state(constraint[0])

        # Format the right side.
        right_side = map(LaTeXFormatter.format_state, constraint[1])
        right_side = " + ".join(right_side)

        # Join the strings.
        constraint_ = "".join([left_side, " = ", right_side])

        return constraint_

    @staticmethod
    def format_equation(equation: tuple, order: int = 0) -> str:
        """ Gets the string that represents an equation from a Master Equation
            in LaTeX format.

            :param equation: The tuple that contains, in order: 1. The state for
             which the master equation will be written. 2. The dictionary of the
             states that will decay to the state for which the master equation
             will be written; where the keys are the associated decay rate
             constants for each process. Multiplicity of the states are
             included. 3. The dictionary of the states to which the state will
             decay due to the different processes; where the keys are the
             associated decay rate constants for each process. Multiplicity of
             the states are included.

            :param order: The order to which the state must be expanded. Order
             zero means the state must not be modified. Higher orders means the
             state must be mean-field expanded to the given order.

            :return: The string that represents the Master Equation in LaTeX
             format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_create_decay(key0: str, create_states0: list, decay_states0: list) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The string that represents the key that is being
                 formatted.

                :param create_states0: The list of strings with the create
                 states associated with the key.

                :param decay_states0: The list of strings with the decay states
                 associated with the key.

                :return: The string that represents the specific term in the
                 equation.
            """

            string_key0 = LaTeXFormatter.format_rate(key0)

            create_string0 = "+".join(create_states0)
            decay_string0 = "".join(["-", "-".join(decay_states0)])

            create_decay_string0 = "".join([f"+{string_key0} \\left(", create_string0, decay_string0, f"\\right)"])

            return create_decay_string0

        def format_create_decay_single(key0: str, states0: list, decay0: bool = False) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The key of the dictionary that is being formatted.

                :param states0: The list of create/decay states from where
                 the states associated with the key must be obtained.

                :param decay0: True, if the requested states to be added are
                 decay states. False, otherwise, i.e., create states.

                :return: The string that represents the specific term in the
                 equation.
            """

            # //////////////////////////////////////////////////////////////////
            # Auxiliary functions.
            # //////////////////////////////////////////////////////////////////

            def get_prefactor(state1: str) -> tuple:
                """ Given a state string, it returns the string of the numerical
                    coefficient, and the stripped state.

                    :param state1: The string that represents the state with
                     the pre-factor already included.

                    :return: A 2-tuple with the pre-factor string and the string
                     state that represents the state without the pre-factor.
                """

                j1 = 0
                str1 = ""
                for character1 in state1:
                    if not str.isnumeric(character1):
                        break

                    str1 += character1
                    j1 += 1

                state1 = state1[j1:] if j1 < len(state1) else state1

                return str1, state1

            # //////////////////////////////////////////////////////////////////
            # Implementation.
            # //////////////////////////////////////////////////////////////////

            key0_ = LaTeXFormatter.format_rate(key0)

            create_decay_string0 = "-" if decay0 else "+"
            if len(states0) == 1:
                prefactor0, create_decay_string0_0 = get_prefactor(states0[0])
                create_decay_string0 = "".join([create_decay_string0, f"{prefactor0} {key0_} {create_decay_string0_0}"])

            else:
                create_decay_string0_ = "".join([f"{key0_} \\left(", "+".join(states0), "\\right)"])
                create_decay_string0 = "".join([create_decay_string0, create_decay_string0_])

            return create_decay_string0

        def format_equation_string(equation0: str) -> str:
            """ Formats the right-hand equation string further to include spaces
                for readability.

                :param equation0: The string that containst the equations to be
                 formatted.

                :return: The string formatted with adequate spacing.
            """

            equation0_ = equation0.strip()

            character0 = "-" if equation0_[0] == "-" else ""
            equation0_ = equation0_[1:] if equation0_[0] == "-" or equation0_[0] == "+" else equation0_
            equation0_ = equation0_.strip()

            equation0_ = " + ".join(equation0_.split("+"))
            equation0_ = " - ".join(equation0_.split("-"))

            equation0_ = character0 + equation0_

            return equation0_

        def format_state_multiplicity(state0: tuple, order0: int) -> str:
            """ Returns the state string, properly formatted, multiplied by its
                multiplicity.

                :param state0: A 2-tuple of the state with its multiplicity.

                :param order0: The order to which the state must be
                 approximated.

                :return: The state string, properly formatted, multiplied by its
                 multiplicity.
            """

            state0_ = str(state0[1]) if state0[1] > 1 else ""
            state0_ = "".join([state0_, LaTeXFormatter.format_state(state0[0], order0)])

            return state0_

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the left-hand of the equation.
        # ----------------------------------------------------------------------

        diff_state = "".join(["\\frac{d", LaTeXFormatter.format_state(equation[0]), "}{dt} ="])

        # ----------------------------------------------------------------------
        # Get the right-hand of the equation.
        # ----------------------------------------------------------------------

        # Setup the variables.
        keys = tuple(key for key in equation[1].keys())
        equation_string = ""
        create = equation[1]
        decay = equation[2]

        # For every key.
        for key in keys:
            create_states = [format_state_multiplicity(state, order) for state in create[key]]
            decay_states = [format_state_multiplicity(state, order) for state in decay[key]]

            # Consider the different formatting cases.
            if len(decay_states) > 0 and len(create_states) == 0:
                decay_string = format_create_decay_single(key, decay_states, decay0=True)
                equation_string += decay_string

            elif len(decay_states) == 0 and len(create_states) > 0:
                create_string = format_create_decay_single(key, create_states, decay0=False)
                equation_string += create_string

            elif len(decay_states) > 0 and len(create_states) > 0:
                create_decay_string = format_create_decay(key, create_states, decay_states)
                equation_string += create_decay_string

        # ----------------------------------------------------------------------
        # Finish formatting the equation string.
        # ----------------------------------------------------------------------

        equation_string = format_equation_string(equation_string)
        equation_string = diff_state + equation_string

        return equation_string

    @staticmethod
    def format_final(quantities: dict) -> str:
        """ Formats the equations and the different quantities such that they
            are ready to be saved in a string.

            :param quantities: A dictionary that MUST have the following
             keys and variables: 1. "constraints": A list of strings of
             constraints. 2. "equations": A list of strings of the equations.
             3. "initial conditions": A list of the strings of the initial
             conditions. 4. "rate values": A list of the strings with the values
             of the constants. 5. "raw_states": A list with the representation
             of the raw states. For some formats the raw states may be the same
             as the regular states.

            :return: A string of the formatted equations.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_constraints(quantities0: dict) -> str:
            """ Formats the constraints of the system such that they are printed
                as a collection of LaTeX functions.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string that contains the collection of constraints,
                 formatted for LaTeX.
            """

            constraint_list0 = "\n".join(quantities0["constraints"])
            return constraint_list0

        def format_equations(quantities0: dict) -> str:
            """ Formats the equations such that they are printed as a LaTeX
                list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The string that represents a list of LaTeX differential
                 equations, with the initial conditions.
            """

            equations0 = "\n".join(["\n".join(quantities0["equations"]), "\n".join(quantities0["initial conditions"])])
            equations0 = "= ".join(equations0.split("="))
            equations0 = equations0[:-1] if equations0[-1] == "\n" else equations0

            return equations0

        def format_rates(quantities0: dict) -> str:
            """ Formats the rates such that they are printed as a collection of
                LaTeX equalities.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The list of formatted rates, ready to be placed in the
                 system.
            """

            rates_list0 = "\n".join(quantities0["rate values"])
            return rates_list0

        def format_raw_states(quantities0: dict) -> str:
            """ Formats the raw states, i.e., the names of the states without
                any time dependence, printed as a LaTeX list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The raw states printed as a LaTeX list.
            """

            states0 = "\n".join(quantities0["raw states"])
            return states0

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get strings of the different quantities.
        # ----------------------------------------------------------------------

        constraints_list = format_constraints(quantities)
        equations_list = format_equations(quantities)
        rates_list = format_rates(quantities)
        raw_states_list = format_raw_states(quantities)

        formatted_system = [
            rates_list, raw_states_list, equations_list, constraints_list
        ]

        return "\n".join(formatted_system)

    @staticmethod
    def format_initial_condition(state: tuple, time: Union[float, str] = 0.0, value: Union[float, str] = 0.0) -> str:
        """ Gets the string that represents a state equal to a given initial
            condition that, by default, is set to zero.

            :param state: The state whose initial condition, at the given time,
             takes a given value.

            :param time: The quantity, or a string, that represents the initial
             time at which the initial condition is set. Set to zero by default.

            :param value: A floating point number, or a string, that represents
             the initial condition at the initial time. Set to zero by default.

            :return: The string that represents the initial condition of a
             time-dependent state, in LaTeX format.
        """

        initial_condition = LaTeXFormatter.format_state(state, raw=True)
        initial_condition = "".join([initial_condition, "_{t_{0} =", f"{str(time)}", "} = ", f"{value}"])

        return initial_condition

    @staticmethod
    def format_rate(rate: str, value: Union[float, int, str] = None) -> str:
        """ Gets the string that represents the rate constant in LaTeX format.
            The value is added if needed.

            :param rate: The rate to check. If in the format: "'s1'.'s2'. ...
             .'sN'..", it interprets the periods as sub-indexes of level N.

            :param value: The value to which the rate must be set.

            :return: The rate constant in LaTeX format.
        """

        rate_string = rate.split(".")
        rate_string = "_{".join(rate_string) + "}" * (len(rate_string) - 1)

        if value is not None:
            rate_string = "".join([rate_string, " = ", str(value)])

        return rate_string

    @staticmethod
    def format_state(state: tuple, order: int = 0, raw: bool = False) -> str:
        """ Gets the string that represents a state in LaTeX format.

            :param state: A tuple that represents the state in the format,
             ((particle0, index0), ... ,(particleN, indexN),).

            :param order: The order to which the state must be approximated.
             If zero, the state is NOT approximated.

            :param raw: True, if the raw states must be included. False,
             otherwise.

            :return: The state, to the given order, in LaTeX format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_component(component0: tuple) -> str:
            """ Formats an entry of a state properly.

                :param component0: The component of a state to be formatted.

                :return: The component of a state in string format.
            """

            state0 = f"{component0[0]}" + "_{" + f"{component0[1]}" + "}"
            return state0

        def get_denominator(numerator0: list) -> list:
            """ Gets the denominator for the equations. This is obtained from
                the numerator.

                :param numerator0: A list of the states that represent the
                 numerator of the system.

                :return: The list of states that is generated from the
                 numerator, that will go in the denominator.
            """

            denominator0 = []

            for i0, state0_0 in enumerate(numerator0):
                for j0, state0_1 in enumerate(numerator0):
                    if j0 <= i0:
                        continue

                    intersection0 = list(set(state0_0).intersection(set(state0_1)))
                    if len(intersection0) > 0:
                        denominator0.append(intersection0)

            return denominator0

        def get_numerator(state0: tuple, order0: int) -> list:
            """ Gets the split state to the nth order, using a mean-field
                approximation.

                :param state0: A tuple of tuples that represents the state.

                :param order0: The order to which the equation must be
                 approximated.

                :return: A list of the states that is generated from an nth
                 order mean field approximation.
            """

            numerator0 = []
            for i0, _ in enumerate(state0):
                if i0 + order0 > len(state0):
                    break

                numerator0.append(state0[i0: i0 + order0])

            return numerator0

        def get_state(state0: tuple, raw0: bool) -> str:
            """ Given a state, returns the string representation in LaTeX
                format.

                :param state0: A tuple of 2-tuples.

                :param raw0: True, if the state is a raw state. False,
                 otherwise. It has no effect in this case.

                :return: The reprensentation of a state in LaTeX format.
            """

            if raw0:
                pass

            state0_ = ["\\left<", ",".join(format_component(state0_) for state0_ in state0), "\\right>"]

            return "".join(state0_)

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # Trivial case.
        if order == 0 or order >= len(state):
            state_string = get_state(state, raw)
            return state_string

        # Get the numerator and denominator.
        numerator = get_numerator(state, order)
        denominator = get_denominator(numerator)

        # Get the strings for the numerator and denominator.
        numerator = map(lambda x: get_state(x, raw), numerator)
        state_string = "".join(numerator)

        # Format the denominator.
        if len(denominator) > 0:
            denominator = map(lambda x: get_state(x, raw), denominator)
            state_string = ["\\frac{", state_string, "}{", "".join(denominator), "}"]
            state_string = "".join(state_string)

        return state_string

    # --------------------------------------------------------------------------
    # Get Methods.
    # --------------------------------------------------------------------------I

    @staticmethod
    def get_format_methods() -> dict:
        """ Returns a dictionary with the possible quantities to be formatted.

            :return: A dictionary with the possible quantities to be obtained by
             the LaTeX formatter.
        """

        # The dictionary of the possible features to format.
        formatter_functions = {
            "constraint": LaTeXFormatter.format_constraint,
            "equation": LaTeXFormatter.format_equation,
            "final": LaTeXFormatter.format_final,
            "initial condition": LaTeXFormatter.format_initial_condition,
            "rate": LaTeXFormatter.format_rate,
            "state": LaTeXFormatter.format_state
        }

        return formatter_functions
