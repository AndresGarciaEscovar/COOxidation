""" Equation formatter for LaTeX."""

# ------------------------------------------------------------------------------
# Imports.
# ------------------------------------------------------------------------------

# Imports: General.
from typing import List, Tuple, Union

# Imports: User-defined.
from coOxidation.Program.Analytic.Interfaces.formatter import Formatter

# ------------------------------------------------------------------------------
# Classes.
# ------------------------------------------------------------------------------


class LaTeXFormatter(Formatter):
    """ A static class that contains equation formatting functions that are
        generated by the equation generator.
    """

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Public Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Format Methods.
    # --------------------------------------------------------------------------I

    @staticmethod
    def get_format_methods() -> dict:
        """ Returns a dictionary with the possible quantities to be formatted.

            :return: A dictionary with the possible quantities to be obtained by
             the LaTeX formatter.
        """

        # The dictionary of the possible features to format.
        formatter_functions = {
            "constraint": LaTeXFormatter._format_constraint,
            "equation": LaTeXFormatter._format_equation,
            "final": LaTeXFormatter._format_final,
            "initial condition": LaTeXFormatter._format_initial_condition,
            "rate": LaTeXFormatter._format_rate,
            "state": LaTeXFormatter._format_state
        }

        return formatter_functions

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Private Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Format Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def _format_constraint(constraint: Tuple) -> str:
        """ Gets the string that represents a constraint of the system in
            LaTeX format.

            :param constraint: The variable that contains a constraint, in the
             form of an equality.

            :return: The string that represents the constraint in LaTeX format.
        """

        # ----------------------------------------------------------------------
        # Format the left side.
        # ----------------------------------------------------------------------

        # Get the representation of the left-hand state.
        left_side = LaTeXFormatter._format_state(constraint[0])

        # ----------------------------------------------------------------------
        # Format the right side.
        # ----------------------------------------------------------------------

        # Get the representation of the right-hand states.
        right_side = map(LaTeXFormatter.get_state, constraint[1])

        # Format it in LaTeX form.
        right_side = " + ".join(right_side)

        # ----------------------------------------------------------------------
        # Join the strings.
        # ----------------------------------------------------------------------

        # Join the strings.
        constraint_ = left_side + " = " + right_side

        return constraint_

    @staticmethod
    def _format_equation(equation: Tuple, order: int = 0) -> str:
        """ Gets the string that represents an equation from a Master Equation
            in LaTeX format.

            :param equation: The tuple that contains, in order: 1. The state for
             which the master equation will be written. 2. The dictionary of the
             states that will decay to the state for which the master equation
             will be written; where the keys are the associated decay rate
             constants for each process. Multiplicity of the states are
             included. 3. The dictionary of the states to which the state will
             decay due to the different processes; where the keys are the
             associated decay rate constants for each process. Multiplicity of
             the states are included.

            :param order: The order to which the state must be expanded. Order
             zero means the state must not be modified. Higher orders means the
             state must be mean-field expanded to the given order.

            :return: The string that represents the Master Equation in LaTeX
             format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_create_decay(key0: str, create_states0: List, decay_states0: List) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The string that represents the key that is being
                 formatted.

                :param create_states0: The list of strings with the create
                 states associated with the key.

                :param decay_states0: The list of strings with the decay states
                 associated with the key.

                :return: The string that represents the specific term in the
                 equation.
            """

            # Get the string representation of the key.
            string_key0 = LaTeXFormatter._format_rate(key0)

            # Join the states in the create states list.
            create_string0 = "+".join(create_states0)

            # Join the states in the decay states list.
            decay_string0 = "-" + "-".join(decay_states0)

            # Join the strings.
            create_decay_string0 = f"+{string_key0} \\left(" + create_string0 + decay_string0 + f"\\right)"

            return create_decay_string0

        def format_create_decay_single(key0: str, states0: list, decay0: bool = False) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The key of the dictionary that is being formatted.

                :param states0: The list of create/decay states from where
                 the states associated with the key must be obtained.

                :param decay0: True, if the requested states to be added are
                 decay states. False, otherwise, i.e., create states.

                :return: The string that represents the specific term in the
                 equation.
            """

            # //////////////////////////////////////////////////////////////////
            # Auxiliary functions.
            # //////////////////////////////////////////////////////////////////

            def get_prefactor(state1: str) -> tuple:
                """ Given a state string, it returns the string of the numerical
                    coefficient, and the stripped state.

                    :param state1: The string that represents the state with
                     the pre-factor already included.

                    :return: A 2-tuple with the pre-factor string and the string
                     state that represents the state without the pre-factor.
                """

                # Auxiliary variables.
                j1 = 0
                str1 = ""

                # Every character in the string.
                for character1 in state1:
                    # If the character is not a number.
                    if not str.isnumeric(character1):
                        break

                    # Add the character to the string.
                    str1 += character1

                    # Add one to the counter.
                    j1 += 1

                # Format the string properly.
                state1 = state1[j1:] if j1 < len(state1) else state1

                return str1, state1

            # //////////////////////////////////////////////////////////////////
            # Implementation.
            # //////////////////////////////////////////////////////////////////

            # Get the string representation of the key.
            key0_ = LaTeXFormatter.get_rate(key0)

            # Initialize the string and the negative sign as needed.
            create_decay_string0 = "-" if decay0 else "+"

            # If there is only one state.
            if len(states0) == 1:
                # Get the prefactor and state.
                prefactor0, create_decay_string0_0 = get_prefactor(states0[0])

                # Join the string.
                create_decay_string0 += f"{prefactor0} {key0_} {create_decay_string0_0}"

            else:
                # Join the states.
                create_decay_string0 += f"{key0_} \\left(" + "+".join(states0) + "\\right)"

            return create_decay_string0

        def format_equation_string(equation0: str) -> str:
            """ Formats the right-hand equation string further to include spaces
                for readability.

                :param equation0: The string that containst the equations to be
                 formatted.

                :return: The string formatted with adequate spacing.
            """

            # Strip all the leading and trailing spaces.
            equation0_ = equation0.strip()

            # Save the negative character if needed.
            first_character0 = "-" if equation0_[0] == "-" else ""

            # Determine if there is a positive or negative sign at the start.
            equation0_ = equation0_[1:] if equation0_[0] == "-" or equation0_[0] == "+" else equation0_

            # Strip all the leading and trailing spaces, again.
            equation0_ = equation0_.strip()

            # Space the positive and negative signs correctly.
            equation0_ = " + ".join(equation0_.split("+"))
            equation0_ = " - ".join(equation0_.split("-"))

            # Add the first character.
            equation0_ = first_character0 + equation0_

            return equation0_

        def format_state_multiplicity(state0: tuple, order0: int) -> str:
            """ Returns the state string, properly formatted, multiplied by its
                multiplicity.

                :param state0: A 2-tuple of the state with its multiplicity.

                :param order0: The order to which the state must be
                 approximated.

                :return: The state string, properly formatted, multiplied by its
                 multiplicity.
            """

            # Check that the state is an iterable of length 2.
            if not len(state0) == 2:
                raise ValueError("To properly format the state it must be a"
                                 " tuple of lenght 2.")

            # Get the multiplicity.
            state0_ = str(state0[1]) if state0[1] > 1 else ""

            # Get the state representation.
            state0_ += LaTeXFormatter.get_state(state0[0], order0)

            return state0_

        # //////////////////////////////////////////////////////////////////////
        # Implementation
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the left-hand of the equation.
        # ----------------------------------------------------------------------

        # Get the differential form.
        diff_state = "\\frac{d" + LaTeXFormatter.get_state(equation[0]) + "}{dt} ="

        # ----------------------------------------------------------------------
        # Get the right-hand of the equation.
        # ----------------------------------------------------------------------

        # ------------------ Get the keys in the dictionaries ------------------

        # Auxiliary variables.
        keys = tuple(key for key in equation[1].keys())

        # The string where the equation will be stored.
        equation_string = ""

        # For every key.
        for key in keys:
            # Get the create states representations.
            create_states = [format_state_multiplicity(state, order) for state in equation[1][key]]

            # Get the decay states representations.
            decay_states = [format_state_multiplicity(state, order) for state in equation[2][key]]

            # If there are decay states but no creation states.
            if len(decay_states) > 0 and len(create_states) == 0:
                # Get the decay string.
                decay_string = format_create_decay_single(key, decay_states, decay0=True)

                # Add to the equation string.
                equation_string += decay_string

            # If there are no decay states, but there are creation states.
            elif len(decay_states) == 0 and len(create_states) > 0:
                # Get the create string.
                create_string = format_create_decay_single(key, create_states, decay0=False)

                # Add to the equation string.
                equation_string += create_string

            # If there are both decay states and creation states.
            elif len(decay_states) > 0 and len(create_states) > 0:
                # Get the decay and create string.
                create_decay_string = format_create_decay(key, create_states, decay_states)

                # Add to the equation string.
                equation_string += create_decay_string

        # Format the string properly.
        equation_string = format_equation_string(equation_string)

        # Join the strings.
        equation_string = diff_state + equation_string

        return equation_string

    @staticmethod
    def get_initial_condition(state: tuple, time: Union[float, str] = 0.0, value: Union[float, str] = 0.0) -> str:
        """ Gets the string that represents a state equal to a given initial
            condition that, by default, is set to zero.

            :param state: The state whose initial, at the given time, takes a
             given value.

            :param time: A floating point number, or a string, that represents
             the initial time at which the initial condition is set. Set to zero
             by default.

            :param value: A floating point number, or a string, that represents
             the initial condition at the initial time. Set to zero by default.

            :return: The string that represents the initial condition of a
             time-dependent state.
        """
        # Add a sub-index to the state.
        initial_condition = LaTeXFormatter.get_state(state) + "_{t_{0} =" + f"{str(time)}" + "} = " + f"{value}"

        return initial_condition

    @staticmethod
    def get_rate(rate: str) -> str:
        """ Gets the string that represents a rate constant in LaTeX format.

            :param rate: The rate string to turn into a LaTeX variable. If it is
             in the format: "'s1'.'s2'. ... .'sN'..", it interprets the periods
             as sub-indexes of level N.

            :return: The rate constant in LaTeX format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def validate_rate(rate0: str) -> None:
            """ Validates that the rate is given in the proper format.

                :param rate0: The representation of the rate that must be a
                 string.
            """

            # Check that it is a string.
            if not isinstance(rate0, (str,)):
                raise TypeError(f"The rate parameter must be string. Current type: {type(rate0)}")

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # Validate the form of the rate.
        validate_rate(rate)

        # Split the string.
        rate_string = rate.split(".")

        # Join the string properly.
        rate_string = "_{".join(rate_string) + "}" * (len(rate_string) - 1)

        return rate_string

    @staticmethod
    def get_rate_value(rate: str, value: float = 0.0) -> str:
        """ Gets the string that represents a rate constant in LaTeX format,
            with the given value.

            :param rate: The rate string to turn into a LaTeX variable. If it is
             in the format: "'s1'.'s2'. ... .'sN'..", it interprets the periods
             as sub-indexes of level N.

            :param value: The numerical value of the rate. Set to zero as
             default.

            :return: The rate constant in LaTeX format.
        """

        # Get the rate representation.
        rate_string = LaTeXFormatter.get_rate(rate)

        # Set the value.
        rate_string += f" = {value}"

        return rate_string

    @staticmethod
    def get_state(state: tuple, order: int = 0) -> str:
        """ Gets the string that represents a state in LaTeX format.

            :param state: A tuple that represents the state in the format,
             ((particle0, index0), ... ,(particleN, indexN),).

            :param order: The order to which the state must be approximated.
             If zero, the state is NOT approximated.

            :return: The state, to the given order, in LaTeX format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_component(component0: tuple) -> str:
            """ Formats an entry of a state properly.

                :param component0: The component of a state to be formatted.

                :return: The component of a state in string format.
            """

            # Get the representation of the single component.
            state0 = f"{component0[0]}" + "_{" + f"{component0[1]}" + "}"

            return state0

        def get_denominator(numerator0: list) -> list:
            """ Gets the denominator for the equations. This is obtained from
                the numerator.

                :param numerator0: A list of the states that represent the
                 numerator of the system.

                :return: The list of states that is generated from the
                 numerator, that will go in the denominator.
            """

            # Auxiliary variables.
            denominator0 = []

            # For every ith state.
            for i0, state0_0 in enumerate(numerator0):
                # For every jth state.
                for j0, state0_1 in enumerate(numerator0):
                    # The denominator will be the intersection of the states.
                    if j0 <= i0:
                        continue

                    # Get the intersecting states.
                    intersection0 = list(set(state0_0).intersection(set(state0_1)))

                    # If there are intersecting states.
                    if len(intersection0) > 0:
                        # Extend the list if there is intersection.
                        denominator0.append(intersection0)

            return denominator0

        def get_numerator(state0: tuple, order0: int) -> list:
            """ Gets the split state to the nth order, using a mean-field
                approximation.

                :param state0: A tuple of tuples that represents the state.

                :param order0: The order to which the equation must be
                 approximated.

                :return: A list of the states that is generated from an nth
                 order mean field approximation.
            """

            # The list where the numerator terms will be stored.
            numerator0 = []

            # For every index in the state.
            for i0, _ in enumerate(state0):
                # Cannot generate more states.
                if i0 + order0 > len(state0):
                    break

                # Append the substate.
                numerator0.append(state0[i0: i0 + order0])

            return numerator0

        def get_state(state0: tuple) -> str:
            """ Given a state it returns the string representation.

                :param state0: A tuple of 2-tuples.

                :return: The CLOSED reprensentation of a state.
            """

            # Get list of the formatted string for each sub-state.
            substate0 = list(map(format_component, state0))

            # Get the exact representation of the state.
            state0_ = "\\left<" + ",".join(substate0) + "\\right>"

            return state0_

        def validate_state(state0: tuple, order0: int) -> None:
            """ Validates that the state is given in the proper format.

                :param state0: The state to be formatted.

                :param order0: The order to which the state must be
                 approximated.
            """

            # The order must a number greater than zero.
            if not 0 <= order0:
                raise ValueError(f"The order must be a positive value. Current Value {order0}.")

            # Check that it is a tuple.
            if not isinstance(state0, (tuple,)):
                raise TypeError(f"The state parameter must be a tuple. Current type: {type(state0)}")

            # Check that the elements are tuples.
            for i0, substate0 in enumerate(state0):
                # Check that it is a tuple.
                if not isinstance(substate0, (tuple,)):
                    raise TypeError(f"The substates of a state must be tuple."
                                    f" State = {state0}, Substate Entry = {i0},"
                                    f" Substate = {substate0}, Current type: {type(substate0)}"
                                    )

                # Of length 2.
                elif not len(substate0) == 2:
                    raise TypeError(f"The substates of a state must be tuple of length 2. "
                                    f" State = {state0}, Substate Entry = {i0},"
                                    f" Substate = {substate0},  Current length of substate: {len(substate0)}."
                                    )

        # ----------------------------------------------------------------------
        # Implementation.
        # ----------------------------------------------------------------------

        # Always validate the state.
        validate_state(state, order)

        # If the requested order is zero.
        if order == 0 or order >= len(state):
            # Get the string representation of the state.
            state_string = get_state(state)

            return state_string

        # Split the state in the requested order.
        numerator = get_numerator(state, order)

        # Get the denominator states.
        denominator = get_denominator(numerator)

        # ----------------------------------------------------------------------
        # Get the strings for the numerator and denominator.
        # ----------------------------------------------------------------------

        # Strings for the numerator states.
        numerator = list(map(get_state, numerator))

        # Format the string.
        state_string = "".join(numerator)

        # Get the denominator strings.
        if len(denominator) > 0:
            # Strings for the denominator states.
            denominator = list(map(get_state, denominator))

            # Format the string.
            state_string = "\\frac{" + state_string + "}{" + "".join(denominator) + "}"

        return state_string

    @staticmethod
    def get_state_raw(state: tuple) -> str:
        """ Gets the string that represents a 'raw state' in LaTeX format.

            :param state: A state in the format ((particle0, index0), ... ,
             (particleN, indexN),).

            :return: The string that represents the state, to the given order,
             in LaTeX format. In some cases, the raw format might be the
             same as the regular format.
        """

        # Get the string representation of the state.
        state_string = LaTeXFormatter.get_state(state)

        return state_string

    # --------------------------------------------------------------------------
    # Join Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def join_equations(quantities: dict) -> str:
        """ Formats the equations and the different quantities such that they
            are ready to be saved in a string.

            :param quantities: A dictionary that MUST have the following
             keys and variables: 1. "constraints": A list of strings of
             constraints. 2. "equations": A list of strings of the equations.
             3. "initial conditions": A list of the strings of the initial
             conditions. 4. "rate values": A list of the strings with the values
             of the constants. 5. "raw_states": A list with the representation
             of the raw states. For some formats the raw states may be the same
             as the regular states.

            :return: A string of the formatted equations.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_constraints(quantities0: dict) -> str:
            """ Formats the constraints of the system such that they are printed
                as a collection of LaTeX functions.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string that contains the collection of constraints,
                 formatted for LaTeX.
            """

            # Join the constrains list.
            constraint_list0 = "\n".join(quantities0["constraints"])

            return constraint_list0

        def format_equations(quantities0: dict) -> str:
            """ Formats the equations such that they are printed as a
                LaTeX list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The string that represents a list of LaTeX differential
                 equations, with the initial conditions.
            """

            # Join the list of equations with the initial conditions.
            equations0 = "\n".join(quantities0["equations"]) + "\n" + "\n".join(quantities0["initial conditions"])

            # Format spacing of the equality sign properly.
            equations0 = "= ".join(equations0.split("="))

            # Format it so that it reads easily when exported to LaTeX.
            equations0 = equations0[:-1] if equations0[-1] == "\n" else equations0

            return equations0

        def format_rates(quantities0: dict) -> str:
            """ Formats the rates such that they are printed as a collection of
                LaTeX equalities.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The list of formatted rates, ready to be placed in the
                 system.
            """

            # Join the list of rates.
            rates_list0 = "\n".join(quantities0["rate values"])

            return rates_list0

        def format_raw_states(quantities0: dict) -> str:
            """ Formats the raw states, i.e., the names of the states without
                any time dependence, printed as a LaTeX list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The raw states printed as a LaTeX list.
            """

            # Join the list of equations with the initial conditions.
            raw_states0 = "\n".join(quantities0["raw states"])

            return raw_states0

        def validate_dictionary(quantities0: dict, keys0: list) -> None:
            """ Validates that the dictionary is consistent.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :param keys0: The keys in the dictionary.
            """

            # Get ALL the keys.
            keys0_ = [key0_1 for key0_1 in quantities0.keys()]

            # Validate that it is a dictionary.
            if not isinstance(quantities0, (dict,)):
                raise TypeError("The quantities parameter must be a dictionary.")

            # Validate the entries.
            if not set(keys0_) == set(keys0):
                raise ValueError(f"The keys in the dictionary must be {keys0}."
                                 f" Current keys = {keys0_}.")

        # //////////////////////////////////////////////////////////////////////
        # Implementation
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the keys and validate the dictionary.
        # ----------------------------------------------------------------------

        # Dictionary keys are.
        keys = ["constraints", "equations", "initial conditions", "rate values", "raw states"]

        # Always validate first.
        validate_dictionary(quantities, keys)

        # ----------------------------------------------------------------------
        # Get strings of the different quantities.
        # ----------------------------------------------------------------------

        # Get the constraints string.
        constraints_list = format_constraints(quantities)

        # Get the formatted equations and initial conditions string.
        equations_list = format_equations(quantities)

        # Get the rates list string.
        rates_list = format_rates(quantities)

        # Get the list of raw variables string.
        raw_states_list = format_raw_states(quantities)

        # ----------------------------------------------------------------------
        # Join the final string.
        # ----------------------------------------------------------------------

        # Join the strings in the proper order string.
        formatted_system = rates_list + "\n" + raw_states_list + "\n" + equations_list + "\n" + constraints_list

        return formatted_system
