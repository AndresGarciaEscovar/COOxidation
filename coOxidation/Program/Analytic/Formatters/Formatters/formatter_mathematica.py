""" Equation formatter for Mathematica."""

# ------------------------------------------------------------------------------
# Imports.
# ------------------------------------------------------------------------------

# Imports: General.
from typing import Union

# Imports: User-defined.
from coOxidation.Program.Analytic.Interfaces.formatter import Formatter

# ------------------------------------------------------------------------------
# Classes.
# ------------------------------------------------------------------------------


class MathematicaFormatter(Formatter):
    """ A static class that contains equation formatting functions that are
        generated by the equation generator.
    """

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Public Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Get Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def get_constraint(constraint):
        """ Gets the string that represents a constraint(s) of the system in
            Mathematica format.

            :param constraint: The variable that contains the constraint, in the
             form of equalities.

            :return: The string that represents the constraint in Mathematica
             format.
        """

        # ----------------------------------------------------------------------
        # Auxiliary functions.
        # ----------------------------------------------------------------------

        # Get the lowest order state.
        low_state_string = MathematicaFormatter.get_state(constraint[0])

        # Define it as a mathematica function.
        low_state_string = "".join(low_state_string.split("[t]")) + "[t_]"

        # Get the other states.
        other_states = list(map(MathematicaFormatter.get_state, constraint[1]))

        # Join the states.
        other_states = " + ".join(other_states)

        # Join the strings.
        constraint_string = low_state_string + " := " + other_states

        return constraint_string

    @staticmethod
    def get_equation(equation: tuple, order: int = 0) -> str:
        """ Gets the string that represents an equation from a Master Equation
            in Mathematica format.

            :param equation: The tuple that contains, in order: 1. The state for
             which the master equation will be written. 2. The dictionary of the
             states that will decay to the state for which the master equation
             will be written; where the keys are the associated decay rate
             constants for each process. Multiplicity of the states are
             included. 3. The dictionary of the states to which the state will
             decay due to the different processes; where the keys are the
             associated decay rate constants for each process. Multiplicity of
             the states are included.

            :param order: The order to which the state must be expanded. Order
             zero means the state must not be modified. Higher orders means the
             state must be mean-field expanded to the given order.

            :return: The string that represents the Master Equation in
             Mathematica format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_create_decay(key0, create_states0, decay_states0):
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The key that is being formatted.

                :param create_states0: The create states associated with the
                key.

                :param decay_states0: The decay states associated with the key.

                :return create_decay_string0: The string that represents the
                specific term in the equation.
            """

            # Get the string representation of the key.
            string_key = MathematicaFormatter.get_rate(key0)

            # Join the states in the create states list.
            create_string0 = "+".join(create_states0)

            # Join the states in the decay states list.
            decay_string0 = "-" + "-".join(decay_states0)

            # Join the strings.
            create_decay_string0 = f"+{string_key} (" + create_string0 + decay_string0 + f")"

            return create_decay_string0

        def format_create_decay_single(key0: str, states0: dict, decay: bool = False) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The key of the dictionary that is being formatted.

                :param states0: The dictionary of create/decay states from where
                 the states associated with the key must be obtained.

                :param decay: True, if the requested states to be added are
                 decay states. False, otherwise, i.e., create states.

                :return: The string that represents the specific term in the
                 equation.
            """

            # //////////////////////////////////////////////////////////////////
            # Auxiliary functions.
            # //////////////////////////////////////////////////////////////////

            def get_prefactor(state1: str) -> tuple:
                """ Given a state string, it returns the string of the numerical
                    coefficient, and the stripped state.

                    :param state1: The string that represents the state with
                     the pre-factor already included.

                    :return: A 2-tuple with the pre-factor string and the string
                     state that represents the state without the pre-factor.
                """

                # Auxiliary variables.
                j1 = 0
                str1 = ""

                # Every character in the string.
                for character1 in state1:
                    # If the character is not a number.
                    if not str.isnumeric(character1):
                        break

                    # Add the character to the string.
                    str1 += character1

                    # Add one to the counter.
                    j1 += 1

                # Format the string properly.
                state1 = state1[j1:] if j1 < len(state1) else state1

                return str1, state1

            # //////////////////////////////////////////////////////////////////
            # Implementation.
            # //////////////////////////////////////////////////////////////////

            # Get the string representation of the key.
            key0_ = MathematicaFormatter.get_rate(key0)

            # Initialize the string and the negative sign as needed.
            create_decay_string0 = "-" if decay else "+"

            # If there is only one state.
            if len(states0) == 1:
                # Get the prefactor and state.
                prefactor0, create_decay_string0_0 = get_prefactor(states0[0])

                # Join the string.
                create_decay_string0 += f"{prefactor0} {key0_} {create_decay_string0_0}"

            else:
                # Join the states.
                create_decay_string0 += f"{key0_} (" + "+".join(states0) + ")"

            return create_decay_string0

        def format_equation_string(equation0: str) -> str:
            """ Formats the right-hand equation string further to include spaces
                for readability.

                :param equation0: The string that containst the equations to be
                 formatted.

                :return: The string formatted with adequate spacing.
            """

            # Strip all the leading and trailing spaces.
            equation0_ = equation0.strip()

            # Save the negative character if needed.
            character0 = "-" if equation0_[0] == "-" else ""

            # Determine if there is a positive or negative sign at the start.
            equation0_ = equation0_[1:] if equation0_[0] == "+" or equation0_[0] == "-" else equation0_

            # Strip all the leading and trailing spaces, again.
            equation0_ = equation0_.strip()

            # Space the positive and negative signs correctly.
            equation0_ = " + ".join(equation0_.split("+"))
            equation0_ = " - ".join(equation0_.split("-"))

            # Add the first character.
            equation0_ = character0 + equation0_

            return equation0_

        def format_state_multiplicity(state0: tuple) -> str:
            """ Returns the state string, properly formatted, multiplied by its
                multiplicity.

                :param state0: A 2-tuple of the state with its multiplicity.

                :return: The state string, properly formatted, multiplied by its
                 multiplicity.
            """

            # Check that the state is an iterable of length 2.
            if not len(state0) == 2:
                raise ValueError("To properly format the state it must be a"
                                 " tuple of lenght 2.")

            # Get the multiplicity.
            state0_0 = str(state0[1]) if state0[1] > 1 else ""

            # Get the state representation.
            state0_0 += MathematicaFormatter.get_state(state0[0], order)

            return state0_0

        def validate_equation(equation0: tuple):
            """ Validates that the equation is given in the proper format.

                :param equation0: The tuple that contains, in order: 1. The
                 state for which the master equation will be written. 2. The
                 dictionary of the states that will decay to the state for which
                 the master equation will be written; where the keys are the
                 associated decay rate constants for each process. Multiplicity
                 of the states are included. 3. The dictionary of the states to
                 which the state will decay due to the different processes;
                 where the keys are the associated decay rate constants for each
                 process. Multiplicity of the states are included.
            """

            # Check that the equation is tuple.
            if not isinstance(equation0, (tuple,)):
                raise TypeError(f"The equation must be a tuple. Current type: {type(equation0)}.")

            # Of length 3.
            elif not len(equation0) == 3:
                raise TypeError(f"The equation must be a tuple of three entries."
                                f" Current type: {type(equation0)}, Length = {len(equation0)}"
                                )

            # Validate that the zeroth entry is a state.
            validate_state(equation0[0])

            # Validate that the first and second entries are dictionaries.
            if not (isinstance(equation0[1], (dict,)) and isinstance(equation0[2], (dict,))):
                raise TypeError("The two last entries of the tuple must be dictionaries. "
                                f" Dictionary entry [1] = {type(equation0[1])},"
                                f" Dictionary entry [2] = {type(equation0[2])}."
                                )

            # Get the keys to the dictionaries.
            keys0_1 = set(key0 for key0 in equation0[1].keys())
            keys0_2 = set(key0 for key0 in equation0[2].keys())

            # If their keys are different.
            if not keys0_1 == keys0_2:
                raise ValueError(f"Both Dictionaries must have the same keys"
                                 f" Keys for equation[1]: {keys0_1},"
                                 f" Keys for equation[2]: {keys0_2}.")

        def validate_state(state0: tuple):
            """ Validates that the state is given in the proper format.

                :param state0: A state that must be in the format,
                 ((particle0, index0), ... ,(particleN, indexN),).
            """

            # Check that it is a tuple.
            if not isinstance(state0, (tuple,)):
                raise TypeError(f"The state parameter must be a tuple. Current type: {type(state0)}")

            # Check that the elements are tuples.
            for j0, substate0 in enumerate(state0):
                # Check that it is a tuple.
                if not isinstance(substate0, (tuple,)):
                    raise TypeError(f"The substates of a state must be tuple."
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0}, Current type: {type(substate0)}"
                                    )

                # Of length 2.
                elif not len(substate0) == 2:
                    raise TypeError(f"The substates of a state must be tuple of length 2. "
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0},  Current length of substate: {len(substate0)}."
                                    )

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # Validate the equation.
        validate_equation(equation)

        # ----------------------------------------------------------------------
        # Get the left-hand of the equation.
        # ----------------------------------------------------------------------

        # Get the differential form.
        diff_state = "D[" + MathematicaFormatter.get_state(equation[0]) + ", t] == "

        # ----------------------------------------------------------------------
        # Get the right-hand of the equation.
        # ----------------------------------------------------------------------

        # ------------------ Get the keys in the dictionaries ------------------

        # Auxiliary variables.
        keys = tuple(key for key in equation[1].keys())

        # The string where the equation will be stored.
        equation_string = ""

        # For every key.
        for key in keys:
            # Get the create states representations.
            create_states = [format_state_multiplicity(state) for state in equation[1][key]]

            # Get the decay states representations.
            decay_states = [format_state_multiplicity(state) for state in equation[2][key]]

            # If there are decay states but no creation states.
            if len(decay_states) > 0 and len(create_states) == 0:
                # Get the decay string.
                decay_string = format_create_decay_single(key, decay_states, decay=True)

                # Add to the equation string.
                equation_string += decay_string

            # If there are no decay states, but there are creation states.
            elif len(decay_states) == 0 and len(create_states) > 0:
                # Get the create string.
                create_string = format_create_decay_single(key, create_states, decay=False)

                # Add to the equation string.
                equation_string += create_string

            # If there are both decay states and creation states.
            elif len(decay_states) > 0 and len(create_states) > 0:
                # Get the decay and create string.
                create_decay_string = format_create_decay(key, create_states, decay_states)

                # Add to the equation string.
                equation_string += create_decay_string

        # Format the string properly.
        equation_string = format_equation_string(equation_string)

        # Join the strings.
        equation_string = diff_state + equation_string

        return equation_string

    @staticmethod
    def get_initial_condition(state: tuple, time: Union[float, str] = 0.0, value: Union[float, str] = 0.0):
        """ Gets the string that represents a state equal to a given initial
            condition that, by default, is set to zero.

            :param state: The state whose initial, at the given time, takes a
             given value.

            :param time: A floating point number, or a string, that represents
             the initial time at which the initial condition is set. Set to zero
             by default.

            :param value: A floating point number, or a string, that represents
             the initial condition at the initial time. Set to zero by default.

            :return: The string that represents the initial condition of a
             time-dependent state.
        """

        # Remove the time dependency.
        initial_condition_string = "".join(MathematicaFormatter.get_state(state).split("[t]")[:-1])

        # Add the initial condition.
        initial_condition_string += f"[{str(time)}] == {str(value)}"

        return initial_condition_string

    @staticmethod
    def get_rate(rate: str) -> str:
        """ Gets the string that represents a rate constant in Mathematica
            format.

            :param rate: The rate string to turn into a Mathematica variable. If
             it is in the format: "'s1'.'s2'. ... .'sN'..", it interprets the
             periods as sub-indexes of level N.

            :return: The rate constant in the given representation.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def validate_rate(rate0: str):
            """ Validates that the rate is given in the proper format.

                :param rate0: The representation of the rate that must be a
                 string.
            """

            # Check that it is a string.
            if not isinstance(rate0, (str,)):
                raise TypeError(f"The rate parameter must be string. Current type: {type(rate0)}")

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # Validate the form of the rate.
        validate_rate(rate)

        # Split the string.
        rate_string = rate.split(".")

        # Join the string properly, in all upper case.
        rate_string = "".join(rate_string).upper()

        return rate_string

    @staticmethod
    def get_rate_value(rate: str, value: float = 0.0) -> str:
        """ Gets the string that represents a rate constant in Mathematica
            format, with the given value.

            :param rate: The rate string to turn into a Mathematica variable. If
             it is in the format: "'s1'.'s2'. ... .'sN'..", it interprets the
             periods as sub-indexes of level N.

            :param value: The numerical value of the rate. Set to zero as
             default.

            :return: The rate constant in Mathematica format.
        """

        # Get the rate representation.
        rate_string = MathematicaFormatter.get_rate(rate)

        # Set the value.
        rate_string += f" = {value}"

        return rate_string

    @staticmethod
    def get_state(state: tuple, order: int = 0) -> str:
        """ Gets the string that represents a state in Mathematica format.

            :param state: A tuple that represents the state in the format,
             ((particle0, index0), ... ,(particleN, indexN),).

            :param order: The order to which the state must be approximated.
             If zero, the state is NOT approximated.

            :return: The state, to the given order, in Mathematica format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_entry(component0: tuple) -> str:
            """ Formats an entry of a state properly.

                :param component0: The component of a state to be formatted.

                :return: The component of a state in string format.
            """

            # Get the representation of the single entry.
            state0 = f"{component0[0]}{component0[1]}"

            return state0

        def get_denominator(numerator0: list) -> list:
            """ Gets the denominator for the equations. This is obtained from
                the numerator.

                :param numerator0: A list of the states that represent the
                 numerator of the system.

                :return: The list of states that is generated from the
                 numerator, that will go in the denominator.
            """

            # List where the state will be stored.
            denominator0 = []

            # For every ith state.
            for i0, state0_0 in enumerate(numerator0):
                # For every jth state.
                for j0, state0_1 in enumerate(numerator0):
                    # The denominator will be the intersection of the states.
                    if j0 <= i0:
                        continue

                    # Get the intersecting states.
                    intersection0 = list(set(state0_0).intersection(set(state0_1)))

                    # If there are intersecting states.
                    if len(intersection0) > 0:
                        # Extend the list if there is intersection.
                        denominator0.append(intersection0)

            return denominator0

        def get_numerator(state0: tuple, order0: int) -> list:
            """ Gets the split state to the nth order, using a mean-field
                approximation.

                :param state0: A tuple of tuples that represents the state.

                :param order0: The order to which the equation must be
                 approximated.

                :return: A list of the states that is generated from an nth
                 order mean field approximation.
            """

            # The list where the numerator terms will be stored.
            numerator0 = []

            # For every index in the state.
            for i0, _ in enumerate(state0):
                # Cannot generate more states.
                if i0 + order0 > len(state0):
                    break

                # Append the substate.
                numerator0.append(state0[i0: i0 + order0])

            return numerator0

        def get_state(state0: tuple) -> str:
            """ Given a state it returns the string representation.

                :param state0: A tuple of two-tuples.

                :return: The CLOSED reprensentation of a state.
            """

            # Get list of the formatted string for each sub-state.
            substate0 = list(map(format_entry, state0))

            # Get the exact representation of the state.
            state0 = "P" + "".join(substate0) + "[t]"

            return state0

        def validate_state(state0: tuple, order0: int) -> None:
            """ Validates that the state is given in the proper format.

                :param state0: The state to be formatted.

                :param order0: The order to which the state must be
                 approximated.
            """

            # The order must a number greater than zero.
            if not 0 <= order0:
                raise ValueError(f"The order must be a positive value. Current Value {order0}.")

            # Check that it is a tuple.
            if not isinstance(state0, (tuple,)):
                raise TypeError(f"The state parameter must be a tuple. Current type: {type(state0)}")

            # Check that the elements are tuples.
            for j0, substate0 in enumerate(state0):
                # Check that it is a tuple.
                if not isinstance(substate0, (tuple,)):
                    raise TypeError(f"The substates of a state must be tuple."
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0}, Current type: {type(substate0)}"
                                    )

                # That the tuple is of length 2.
                elif not len(substate0) == 2:
                    raise TypeError(f"The substates of a state must be tuple of length 2. "
                                    f" State = {state0}, Substate Entry = {j0},"
                                    f" Substate = {substate0},  Current length of substate: {len(substate0)}."
                                    )

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # Always validate the state.
        validate_state(state, order)

        # ----------------------------------------------------------------------
        # The trivial case.
        # ----------------------------------------------------------------------

        # If the requested order is zero.
        if order == 0 or order >= len(state):
            # Get the string representation of the state.
            state_string = get_state(state)

            return state_string

        # ----------------------------------------------------------------------
        # Get the numerator and denominator.
        # ----------------------------------------------------------------------

        # Get the numerator states.
        numerator = get_numerator(state, order)

        # Get the denominators states.
        denominator = get_denominator(numerator)

        # ----------------------------------------------------------------------
        # Get the strings for the numerator and denominator.
        # ----------------------------------------------------------------------

        # Strings for the numerator states.
        numerator = list(map(get_state, numerator))

        # Format the string.
        state_string = " ".join(numerator)

        # Get the denominator strings.
        if len(denominator) > 0:
            # Strings for the denominator states.
            denominator = list(map(get_state, denominator))

            # Format the string.
            state_string = state_string + "/(" + " ".join(denominator) + ")"

        return state_string

    @staticmethod
    def get_state_raw(state: tuple) -> str:
        """ Gets the string that represents a 'raw state' in Mathematica format.

            :param state: A state in the format ((particle0, index0), ... ,
             (particleN, indexN),).

            :return: The string that represents the state, to the given order,
             in Mathematica format. In some cases, the raw format might be the
             same as the regular format.
        """

        # Get the string representation of the state.
        state_ = MathematicaFormatter.get_state(state)

        # Take the time dependence off and strip the state from leading/trailing spaces.
        state_ = "".join(state_.split("[t]")).strip()

        return state_

    # --------------------------------------------------------------------------
    # Join Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def join_equations(quantities: dict) -> str:
        """ Formats the equations and the different quantities such that they
            are ready to be saved in a string.

            :param quantities: A dictionary that MUST have the following
             keys and variables: 1. "constraints": A list of strings of
             constraints. 2. "equations": A list of strings of the equations.
             3. "initial conditions": A list of the strings of the initial
             conditions. 4. "rate values": A list of the strings with the values
             of the constants. 5. "raw_states": A list with the representation
             of the raw states. For some formats the raw states may be the same
             as the regular states.

            :return: A string of the formatted equations.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_constraints(quantities0: dict) -> str:
            """ Formats the constraints of the system such that they are printed
                as a collection of Mathematica functions.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string that contains the collection of constraints,
                 formatted for Mathematica.
            """

            # Join the constrains list.
            constraints0 = ";\n".join(quantities0["constraints"]) + ";"

            return constraints0

        def format_equations(quantities0: dict) -> str:
            """ Formats the equations such that they are printed as a
                Mathematica list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The string that represents a list of Mathematica
                 differential equations, with the initial conditions, ready to
                 be placed in the NDSolve function.
            """

            # The name of the equations key.
            aux0 = "equations"

            # The name of the initial conditions key.
            aux1 = "initial conditions"

            # Join the list of equations with the initial conditions.
            equations0 = ",".join(quantities0[aux0]) + "," + ",".join(quantities0[aux1])

            # Make it a list.
            equations0 = "equations = {" + equations0 + "};"

            return equations0

        def format_rates(quantities0: dict) -> str:
            """ Formats the rates such that they are printed as a collection of
                Mathematica equalities.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The list of formatted rates, ready to be placed in the
                 system.
            """

            # Join the list of rates.
            rates_list0 = ";".join(quantities0["rate values"]) + ";"

            return rates_list0

        def format_raw_states(quantities0: dict) -> str:
            """ Formats the raw states, i.e., the names of the states without
                any time dependence, printed as a Mathematica list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The raw states printed as a Mathematica list.
            """

            # Join the list of equations with the initial conditions.
            raw_states0 = ",".join(quantities0["raw states"])

            # Name it as a list.
            raw_states0 = "rawStates = {" + raw_states0 + "};"

            return raw_states0

        def format_time_states(quantities0: dict) -> str:
            """ Formats the raw states printed as a string such that it
                represents a Mathematica list with the time-dependent states.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string formatted such that it represents a
                 Mathematica list with the time-dependent states.
            """

            # Join the list of equations with the initial conditions.
            time_states0 = "[t],".join(quantities0["raw states"])

            # Set it as a Mathematica list.
            time_states0 = "timeStates = {" + time_states0 + "[t]};"

            return time_states0

        def validate_dictionary(keys0: list):
            """ Validates that the dictionary is consistent.

                :param keys0: The keys in the dictionary.
            """

            # Get ALL the keys.
            keys0_ = [key0 for key0 in quantities.keys()]

            # Validate that it is a dictionary.
            if not isinstance(quantities, (dict,)):
                raise TypeError("The quantities parameter must be a dictionary.")

            # Validate the entries.
            if not set(keys0_) == set(keys0):
                raise ValueError(f"The keys in the dictionary must be {keys0}."
                                 f" Current keys = {keys0_}.")

        # //////////////////////////////////////////////////////////////////////
        # Implementation
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the keys and validate the dictionary.
        # ----------------------------------------------------------------------

        # The list of the required keys.
        keys = ["constraints", "equations", "initial conditions", "rate values", "raw states"]

        # Validate the required keys are present.
        validate_dictionary(keys)

        # ----------------------------------------------------------------------
        # Get strings of the different quantities.
        # ----------------------------------------------------------------------

        # Get the constraints string.
        constraints_list = format_constraints(quantities)

        # Get the formatted equations and initial conditions string.
        equations_list = format_equations(quantities)

        # Get the rates list string.
        rates_list = format_rates(quantities)

        # Get the list of raw variables string.
        raw_states_list = format_raw_states(quantities)

        # Get the list of time dependent states string.
        time_list = format_time_states(quantities)

        # ----------------------------------------------------------------------
        # Join the final string.
        # ----------------------------------------------------------------------

        # Join the strings in the proper order.
        formatted_system = rates_list + "\n" + raw_states_list + "\n" 
        formatted_system += equations_list + "\n" + time_list + "\n"
        formatted_system += constraints_list

        return formatted_system
