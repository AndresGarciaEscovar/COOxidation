""" Equation formatter for Mathematica."""

# ------------------------------------------------------------------------------
# Imports.
# ------------------------------------------------------------------------------

# Imports: General.
from typing import List, Tuple, Union

# Imports: User-defined.
from coOxidation.Program.Analytic.Interfaces.formatter import Formatter

# ------------------------------------------------------------------------------
# Classes.
# ------------------------------------------------------------------------------


class MathematicaFormatter(Formatter):
    """ A static class that contains equation formatting functions that are
        generated by the equation generator, in this case, Mathematica.
    """

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Public Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Format Methods.
    # --------------------------------------------------------------------------I

    @staticmethod
    def get_format_methods() -> dict:
        """ Returns a dictionary with the possible quantities to be formatted.

            :return: A dictionary with the possible quantities to be obtained by
             the Mathematica formatter.
        """

        # The dictionary of the possible features to format.
        formatter_functions = {
            "constraint": MathematicaFormatter._format_constraint,
            "equation": MathematicaFormatter._format_equation,
            "final": MathematicaFormatter._format_final,
            "initial condition": MathematicaFormatter._format_initial_condition,
            "rate": MathematicaFormatter._format_rate,
            "state": MathematicaFormatter._format_state
        }

        return formatter_functions

    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # Private Interface.
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

    # --------------------------------------------------------------------------
    # Format Methods.
    # --------------------------------------------------------------------------

    @staticmethod
    def _format_constraint(constraint: Tuple) -> str:
        """ Gets the string that represents a constraint of the system in
            Mathematica format.

            :param constraint: The variable that contains a constraint, in the
             form of an equality.

            :return: The string that represents the constraint in Mathematica
             format.
        """

        # ----------------------------------------------------------------------
        # Format the left side.
        # ----------------------------------------------------------------------

        # Get the representation of the left-hand state.
        left_side = MathematicaFormatter._format_state(constraint[0])

        # Format it in mathematica form.
        left_side = "".join(left_side.split("[t]")) + "[t_]"

        # ----------------------------------------------------------------------
        # Format the right side.
        # ----------------------------------------------------------------------

        # Get the representation of the right-hand states.
        right_side = map(MathematicaFormatter._format_state, constraint[1])

        # Format it in Mathematica form.
        right_side = " + ".join(right_side)

        # ----------------------------------------------------------------------
        # Join the strings.
        # ----------------------------------------------------------------------

        # Join the strings.
        constraint_ = left_side + " := " + right_side

        return constraint_

    @staticmethod
    def _format_equation(equation: Tuple, order: int = 0) -> str:
        """ Gets the string that represents an equation from a Master Equation
            in Mathematica format.

            :param equation: The tuple that contains, in order: 1. The state for
             which the master equation will be written. 2. The dictionary of the
             states that will decay to the state for which the master equation
             will be written; where the keys are the associated decay rate
             constants for each process. Multiplicity of the states are
             included. 3. The dictionary of the states to which the state will
             decay due to the different processes; where the keys are the
             associated decay rate constants for each process. Multiplicity of
             the states are included.

            :param order: The order to which the state must be expanded. Order
             zero means the state must not be modified. Higher orders means the
             state must be mean-field expanded to the given order.

            :return: The string that represents the Master Equation in
             Mathematica format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_create_decay(key0: str, create_states0: List, decay_states0: List) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The string that represents the key that is being
                 formatted.

                :param create_states0: The list of strings with the create
                 states associated with the key.

                :param decay_states0: The list of strings with the decay states
                 associated with the key.

                :return: The string that represents the specific term in the
                 equation.
            """

            # Get the string representation of the key.
            string_key0 = MathematicaFormatter._format_rate(key0)

            # Join the states in the create states list.
            create_string0 = "+".join(create_states0)

            # Join the states in the decay states list.
            decay_string0 = "-" + "-".join(decay_states0)

            # Join the strings.
            create_decay_string0 = f"+{string_key0} (" + create_string0 + decay_string0 + f")"

            return create_decay_string0

        def format_create_decay_single(key0: str, states0: List, decay0: bool = False) -> str:
            """ Given the decay states and the key, it formats the string of
                decay states.

                :param key0: The key of the dictionary that is being formatted.

                :param states0: The list of create/decay states from where
                 the states associated with the key must be obtained.

                :param decay0: True, if the requested states to be added are
                 decay states. False, otherwise, i.e., create states.

                :return: The string that represents the specific term in the
                 equation.
            """

            # //////////////////////////////////////////////////////////////////
            # Auxiliary functions.
            # //////////////////////////////////////////////////////////////////

            def get_prefactor(state1: str) -> tuple:
                """ Given a state string, it returns the string of the numerical
                    coefficient, and the stripped state.

                    :param state1: The string that represents the state with
                     the pre-factor already included.

                    :return: A 2-tuple with the pre-factor string and the string
                     state that represents the state without the pre-factor.
                """

                # Auxiliary variables.
                j1 = 0
                str1 = ""

                # Every character in the string.
                for character1 in state1:
                    # If the character is not a number.
                    if not str.isnumeric(character1):
                        break

                    # Add the character to the string.
                    str1 += character1

                    # Add one to the counter.
                    j1 += 1

                # Format the string properly.
                state1 = state1[j1:] if j1 < len(state1) else state1

                return str1, state1

            # //////////////////////////////////////////////////////////////////
            # Implementation.
            # //////////////////////////////////////////////////////////////////

            # Get the string representation of the rate.
            key0_ = MathematicaFormatter._format_rate(key0)

            # Initialize the string and the negative sign as needed.
            create_decay_string0 = "-" if decay0 else "+"

            # If there is only one state.
            if len(states0) == 1:
                # Get the prefactor and state.
                prefactor0, create_decay_string0_0 = get_prefactor(states0[0])

                # Join the string.
                create_decay_string0 += f"{prefactor0} {key0_} {create_decay_string0_0}"

            else:
                # Join the states.
                create_decay_string0 += f"{key0_} (" + "+".join(states0) + ")"

            return create_decay_string0

        def format_equation_string(equation0: str) -> str:
            """ Formats the right-hand equation string further to include spaces
                for readability.

                :param equation0: The string that containst the equations to be
                 formatted.

                :return: The string formatted with adequate spacing.
            """

            # Strip all the leading and trailing spaces.
            equation0_ = equation0.strip()

            # Save the negative character if needed.
            character0 = "-" if equation0_[0] == "-" else ""

            # Determine if there is a positive or negative sign at the start.
            equation0_ = equation0_[1:] if equation0_[0] == "+" or equation0_[0] == "-" else equation0_

            # Strip all the leading and trailing spaces, again.
            equation0_ = equation0_.strip()

            # Space the positive and negative signs correctly.
            equation0_ = " + ".join(equation0_.split("+"))
            equation0_ = " - ".join(equation0_.split("-"))

            # Add the first character.
            equation0_ = character0 + equation0_

            return equation0_

        def format_state_multiplicity(state0: Tuple, order0: int) -> str:
            """ Returns the state string, properly formatted, multiplied by its
                multiplicity.

                :param state0: A 2-tuple of the state with its multiplicity.

                :param order0: The order to which the state must be
                 approximated.

                :return: The state string, properly formatted, with its
                 multiplicity.
            """

            # Get the multiplicity.
            state0_ = str(state0[1]) if state0[1] > 1 else ""

            # Get the state representation.
            state0_ += MathematicaFormatter._format_state(state0[0], order0)

            return state0_

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the left-hand of the equation.
        # ----------------------------------------------------------------------

        # Get the differential form.
        diff_state = "D[" + MathematicaFormatter._format_state(equation[0]) + ", t] == "

        # ----------------------------------------------------------------------
        # Get the right-hand of the equation.
        # ----------------------------------------------------------------------

        # ------------------------ Setup the variables -------------------------

        # Auxiliary variables.
        keys = tuple(key for key in equation[1].keys())

        # The string where the equation will be stored.
        equation_string = ""

        # Get the create states dictionary.
        create = equation[1]

        # Get the decay states dictionary.
        decay = equation[2]

        # ----------- Get the string representation for each process -----------

        # For every key.
        for key in keys:

            # ------------- Get the create and decay state strings -------------

            # Get the create states representations.
            create_states = [format_state_multiplicity(state, order) for state in create[key]]

            # Get the decay states representations.
            decay_states = [format_state_multiplicity(state, order) for state in decay[key]]

            # ----------- Consider the formatting in different cases -----------

            # If there are decay states but no creation states.
            if len(decay_states) > 0 and len(create_states) == 0:
                # Get the decay string.
                decay_string = format_create_decay_single(key, decay_states, decay0=True)

                # Add to the equation string.
                equation_string += decay_string

            # If there are no decay states, but there are creation states.
            elif len(decay_states) == 0 and len(create_states) > 0:
                # Get the create string.
                create_string = format_create_decay_single(key, create_states, decay0=False)

                # Add to the equation string.
                equation_string += create_string

            # If there are both decay states and creation states.
            elif len(decay_states) > 0 and len(create_states) > 0:
                # Get the decay and create string.
                create_decay_string = format_create_decay(key, create_states, decay_states)

                # Add to the equation string.
                equation_string += create_decay_string

        # ----------------------------------------------------------------------
        # Finish formatting the equation string.
        # ----------------------------------------------------------------------

        # Finish formatting the spacing.
        equation_string = format_equation_string(equation_string)

        # Join the strings.
        equation_string = diff_state + equation_string

        return equation_string

    @staticmethod
    def _format_final(quantities: dict) -> str:
        """ Formats the equations and the different quantities such that they
            are ready to be saved in a string.

            :param quantities: A dictionary that MUST have the following
             keys and variables: 1. "constraints": A list of strings of
             constraints. 2. "equations": A list of strings of the equations.
             3. "initial conditions": A list of the strings of the initial
             conditions. 4. "rate values": A list of the strings with the values
             of the constants. 5. "raw_states": A list with the representation
             of the raw states. For some formats the raw states may be the same
             as the regular states.

            :return: A string of the formatted equations.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_constraints(quantities0: dict) -> str:
            """ Formats the constraints of the system such that they are printed
                as a collection of Mathematica functions.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string that contains the collection of constraints,
                 formatted for Mathematica.
            """

            # Join the constrains list.
            constraints0 = ";\n".join(quantities0["constraints"]) + ";"

            return constraints0

        def format_equations(quantities0: dict) -> str:
            """ Formats the equations such that they are printed as a
                Mathematica list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The string that represents a list of Mathematica
                 differential equations, with the initial conditions, ready to
                 be placed in the NDSolve function.
            """

            # The name of the equations key.
            key0 = "equations"

            # The name of the initial conditions key.
            key0_ = "initial conditions"

            # Join the list of equations with the initial conditions.
            equations0 = ",".join(quantities0[key0]) + "," + ",".join(quantities0[key0_])

            # Make it a list.
            equations0 = "equations = {" + equations0 + "};"

            return equations0

        def format_rates(quantities0: dict) -> str:
            """ Formats the rates such that they are printed as a collection of
                Mathematica equalities.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The list of formatted rates, ready to be placed in the
                 system.
            """

            # Join the list of rates.
            rates_list0 = ";".join(quantities0["rate values"]) + ";"

            return rates_list0

        def format_raw_states(quantities0: dict) -> str:
            """ Formats the raw states, i.e., the names of the states without
                any time dependence, printed as a Mathematica list.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: The raw states printed as a Mathematica list.
            """

            # Join the list of equations with the initial conditions.
            raw_states0 = ",".join(quantities0["raw states"])

            # Name it as a list.
            raw_states0 = "rawStates = {" + raw_states0 + "};"

            return raw_states0

        def format_time_states(quantities0: dict) -> str:
            """ Formats the raw states printed as a string such that it
                represents a Mathematica list with the time-dependent states.

                :param quantities0: The dictionary with the quantities to be
                 formatted.

                :return: A string formatted such that it represents a
                 Mathematica list with the time-dependent states.
            """

            # Join the list of equations with the initial conditions.
            time_states0 = "[t],".join(quantities0["raw states"])

            # Set it as a Mathematica list.
            time_states0 = "timeStates = {" + time_states0 + "[t]};"

            return time_states0

        # //////////////////////////////////////////////////////////////////////
        # Implementation
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # Get the keys and validate the dictionary.
        # ----------------------------------------------------------------------

        # The list of the required keys.
        keys = ["constraints", "equations", "initial conditions", "rate values", "raw states"]

        # ----------------------------------------------------------------------
        # Get strings of the different quantities.
        # ----------------------------------------------------------------------

        # Get the constraints string.
        constraints_list = format_constraints(quantities)

        # Get the formatted equations and initial conditions string.
        equations_list = format_equations(quantities)

        # Get the rates list string.
        rates_list = format_rates(quantities)

        # Get the list of raw variables string.
        raw_states_list = format_raw_states(quantities)

        # Get the list of time dependent states string.
        time_list = format_time_states(quantities)

        # ----------------------------------------------------------------------
        # Join the final string.
        # ----------------------------------------------------------------------

        # Join the strings in the proper order.
        formatted_system = rates_list + "\n" + raw_states_list + "\n"
        formatted_system += equations_list + "\n" + time_list + "\n"
        formatted_system += constraints_list

        return formatted_system

    @staticmethod
    def _format_initial_condition(state: Tuple, time: Union[float, str] = 0.0, value: Union[float, str] = 0.0) -> str:
        """ Gets the string that represents a state equal to a given initial
            condition that, by default, is set to zero.

            :param state: The state whose initial condition, at the given time,
             takes a given value.

            :param time: The quantity, or a string, that represents the initial
             time at which the initial condition is set. Set to zero by default.

            :param value: A floating point number, or a string, that represents
             the initial condition at the initial time. Set to zero by default.

            :return: The string that represents the initial condition of a
             time-dependent state, in Mathematica format.
        """

        # Get the raw state.
        initial_condition = MathematicaFormatter._format_state(state, raw=True)

        # Add the initial condition.
        initial_condition += f"[{str(time)}] == {str(value)}"

        return initial_condition

    @staticmethod
    def _format_rate(rate: str, value: Union[float, int, str] = None) -> str:
        """ Gets the string that represents the rate constant in Mathematica
            format. The value is added if needed.

            :param rate: The rate to check. If in the format: "'s1'.'s2'. ...
             .'sN'..", it interprets the periods as sub-indexes of level N.

            :param value: The value to which the rate must be set.

            :return: The rate constant in Mathematica format.
        """

        # Split the string.
        rate_string = rate.split(".")

        # Join the string properly, in all upper case.
        rate_string = "".join(rate_string).upper()

        # If there is a rate value to add.
        if value is not None:
            # Add the value.
            rate_string += " = " + str(value)

        return rate_string

    @staticmethod
    def _format_state(state: Tuple, order: int = 0, raw: bool = False) -> str:
        """ Gets the string that represents a state in Mathematica format.

            :param state: A tuple that represents the state in the format,
             ((particle0, index0), ... ,(particleN, indexN),).

            :param order: The order to which the state must be approximated.
             If zero, the state is NOT approximated.

            :return: The state, to the given order, in Mathematica format.
        """

        # //////////////////////////////////////////////////////////////////////
        # Auxiliary functions.
        # //////////////////////////////////////////////////////////////////////

        def format_component(component0: Tuple) -> str:
            """ Formats an entry of a state properly.

                :param component0: The component of a state to be formatted.

                :return: The component of a state in string format.
            """

            # Get the representation of the single component.
            state0 = f"{component0[0]}{component0[1]}"

            return state0

        def get_denominator(numerator0: List) -> List:
            """ Gets the denominator for the equations. This is obtained from
                the numerator.

                :param numerator0: A list of the states that represent the
                 numerator of the system.

                :return: The list of states that is generated from the
                 numerator, that will go in the denominator.
            """

            # List where the state will be stored.
            denominator0 = []

            # For every ith state.
            for i0, state0_0 in enumerate(numerator0):
                # For every jth state.
                for j0, state0_1 in enumerate(numerator0):
                    # The denominator will be the intersection of the states.
                    if j0 <= i0:
                        continue

                    # Get the intersecting states.
                    intersection0 = list(set(state0_0).intersection(set(state0_1)))

                    # If there are intersecting states.
                    if len(intersection0) > 0:
                        # Extend the list if there is intersection.
                        denominator0.append(intersection0)

            return denominator0

        def get_numerator(state0: Tuple, order0: int) -> List:
            """ Gets the split state to the nth order, using a mean-field
                approximation.

                :param state0: A tuple of tuples that represents the state.

                :param order0: The order to which the equation must be
                 approximated.

                :return: A list of the states that is generated from an nth
                 order mean field approximation.
            """

            # The list where the numerator terms will be stored.
            numerator0 = []

            # For every index in the state.
            for i0, _ in enumerate(state0):
                # Cannot generate more states.
                if i0 + order0 > len(state0):
                    break

                # Append the substate.
                numerator0.append(state0[i0: i0 + order0])

            return numerator0

        def get_state(state0: Tuple, raw0: bool) -> str:
            """ Given a state, returns the string representation in Mathematica
                format.

                :param state0: A tuple of 2-tuples.

                :param raw0: True, if the state is a raw state. False,
                 otherwise.

                :return: The reprensentation of a state in Mathematica format.
            """

            # Get the suffix string of the state.
            suffix0 = "" if raw0 else "[t]"

            # Join the strings.
            state0_ = "P" + "".join(map(format_component, state0)) + suffix0

            return state0_

        # //////////////////////////////////////////////////////////////////////
        # Implementation.
        # //////////////////////////////////////////////////////////////////////

        # ----------------------------------------------------------------------
        # The trivial case.
        # ----------------------------------------------------------------------

        # If the requested order is zero.
        if order == 0 or order >= len(state):
            # Get the string representation of the state.
            state_string = get_state(state, raw)

            return state_string

        # ----------------------------------------------------------------------
        # Get the numerator and denominator.
        # ----------------------------------------------------------------------

        # Get the numerator states.
        numerator = get_numerator(state, order)

        # Get the denominators states.
        denominator = get_denominator(numerator)

        # ----------------------------------------------------------------------
        # Get the strings for the numerator and denominator.
        # ----------------------------------------------------------------------

        # Strings for the numerator states.
        numerator = map(get_state, numerator)

        # Format the string.
        state_string = " ".join(numerator)

        # Get the denominator strings.
        if len(denominator) > 0:
            # Strings for the denominator states.
            denominator = map(get_state, denominator)

            # Format the string.
            state_string = state_string + "/(" + " ".join(denominator) + ")"

        return state_string
